#!/usr/bin/env bash
set -euo pipefail

ACTION="${1:-list}"; shift || true
APPLY=0
for arg in "${@:-}"; do [[ "$arg" == "--apply" ]] && APPLY=1; done

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_DIR="$(cd "$script_dir/.." && pwd)"

die(){ echo "[packs] ERROR: $*" >&2; exit 1; }
log(){ echo "[packs] $*"; }

[[ -f "$BASE_DIR/config/paths.env" ]] || die "Missing config/paths.env (run: ./bin/beast init --apply)"
# shellcheck disable=SC1090
source "$BASE_DIR/config/paths.env"

cfg="$BASE_DIR/config/packs.json"
[[ -f "$cfg" ]] || die "Missing $cfg"

need_cmd(){ command -v "$1" >/dev/null 2>&1 || die "Missing '$1' (run: ./bin/beast bootstrap --apply)"; }

brew_install(){
  local kind="$1"; shift
  local pkgs=("$@")
  [[ "${#pkgs[@]}" -gt 0 ]] || return 0
  if ! command -v brew >/dev/null 2>&1; then
    log "Homebrew not found; skipping brew installs."
    return 0
  fi
  for p in "${pkgs[@]}"; do
    if [[ "$kind" == "cask" ]]; then
      brew list --cask "$p" >/dev/null 2>&1 && { log "brew(cask) already: $p"; continue; }
      if [[ "$APPLY" -ne 1 ]]; then log "DRYRUN brew install --cask $p"; continue; fi
      brew install --cask "$p" || log "WARN: failed cask: $p"
    else
      brew list "$p" >/dev/null 2>&1 && { log "brew already: $p"; continue; }
      if [[ "$APPLY" -ne 1 ]]; then log "DRYRUN brew install $p"; continue; fi
      brew install "$p" || log "WARN: failed formula: $p"
    fi
  done
}

venv_for(){
  local name="$1"
  echo "$BASE_DIR/.venv_packs/$name"
}

pip_install(){
  local name="$1"; shift
  local pkgs=("$@")
  [[ "${#pkgs[@]}" -gt 0 ]] || return 0
  need_cmd python3
  local venv; venv="$(venv_for "$name")"
  if [[ ! -d "$venv" ]]; then
    if [[ "$APPLY" -ne 1 ]]; then
      log "DRYRUN python3 -m venv $venv"
    else
      python3 -m venv "$venv"
      # shellcheck disable=SC1090
      source "$venv/bin/activate"
      pip install -U pip wheel setuptools >/dev/null
      deactivate || true
    fi
  fi
  if [[ "$APPLY" -ne 1 ]]; then
    log "DRYRUN pip install (venv=$venv): ${pkgs[*]}"
    return 0
  fi
  # shellcheck disable=SC1090
  source "$venv/bin/activate"
  pip install -U pip wheel setuptools >/dev/null
  pip install "${pkgs[@]}" || log "WARN: pip install had errors for pack '$name'"
  deactivate || true
}

enable_feature_flag(){
  local key="$1" val="$2"
  local f="$BASE_DIR/config/features.local.yml"
  # features.local.yml overrides features.yml; sync will merge
  if [[ "$APPLY" -ne 1 ]]; then
    log "DRYRUN set $key: $val in $f"
    return 0
  fi
  mkdir -p "$BASE_DIR/config"
  if [[ ! -f "$f" ]]; then
    printf "# Local overrides (generated by packs)
" > "$f"
  fi
  # remove existing key line
  grep -vE "^${key}:" "$f" > "$f.tmp" 2>/dev/null || true
  mv "$f.tmp" "$f" 2>/dev/null || true
  printf "%s: %s
" "$key" "$val" >> "$f"
  log "Set override: $key: $val"
}

install_pack(){
  local name="$1"
  need_cmd jq

  local exists
  exists="$(jq -r --arg n "$name" '.packs[$n] != null' "$cfg")"
  [[ "$exists" == "true" ]] || die "Unknown pack: $name"

  local desc
  desc="$(jq -r --arg n "$name" '.packs[$n].desc' "$cfg")"
  log "Installing pack: $name â€” $desc"

  mapfile -t formulae < <(jq -r --arg n "$name" '.packs[$n].brew.formulae[]? // empty' "$cfg")
  mapfile -t casks    < <(jq -r --arg n "$name" '.packs[$n].brew.casks[]? // empty' "$cfg")
  mapfile -t pips     < <(jq -r --arg n "$name" '.packs[$n].pip[]? // empty' "$cfg")
  mapfile -t exts     < <(jq -r --arg n "$name" '.packs[$n].docker.extensions[]? // empty' "$cfg")

  brew_install formula "${formulae[@]}"
  brew_install cask "${casks[@]}"
  pip_install "$name" "${pips[@]}"

  # optional docker extensions
  for e in "${exts[@]}"; do
    if [[ "$APPLY" -ne 1 ]]; then
      log "DRYRUN ./bin/beast ext install $e --apply"
    else
      "$BASE_DIR/bin/beast" ext install "$e" --apply || log "WARN: ext install failed: $e"
    fi
  done

  # optional feature flags
  jq -r --arg n "$name" '.packs[$n].docker.feature_flags // {} | to_entries[] | "\(.key)=\(.value)"' "$cfg" | while IFS="=" read -r k v; do
    [[ -n "$k" ]] || continue
    if [[ "$v" == "true" ]]; then
      enable_feature_flag "$k" "true"
    elif [[ "$v" == "false" ]]; then
      enable_feature_flag "$k" "false"
    else
      enable_feature_flag "$k" "$v"
    fi
  done

  # pack-specific post actions
  local hook="$BASE_DIR/scripts/packs/${name}.sh"
  if [[ -f "$hook" ]]; then
    bash "$hook" "${APPLY:+--apply}"
  fi

  log "Done: $name"
}

list_packs(){
  need_cmd jq
  jq -r '.packs | to_entries[] | "\(.key)	\(.value.desc)"' "$cfg" | expand -t 24
}

show_pack(){
  local name="$1"
  need_cmd jq
  jq -r --arg n "$name" '.packs[$n]' "$cfg"
}

resolve_deps(){
  # prints ordered list of packs to install, including deps (toposort-ish)
  local want=("$@")
  need_cmd jq
  local seen_file="$BASE_DIR/.cache/packs_seen.$$"
  mkdir -p "$BASE_DIR/.cache"
  : > "$seen_file"

  add_seen(){ grep -Fqx "$1" "$seen_file" 2>/dev/null || echo "$1" >> "$seen_file"; }
  is_seen(){ grep -Fqx "$1" "$seen_file" 2>/dev/null; }

  visit(){
    local p="$1"
    is_seen "$p" && return 0
    local exists
    exists="$(jq -r --arg n "$p" '.packs[$n] != null' "$cfg")"
    [[ "$exists" == "true" ]] || die "Unknown pack: $p"
    mapfile -t deps < <(jq -r --arg n "$p" '.packs[$n].depends[]? // empty' "$cfg")
    for d in "${deps[@]}"; do visit "$d"; done
    add_seen "$p"
  }

  for p in "${want[@]}"; do visit "$p"; done
  cat "$seen_file"
  rm -f "$seen_file" || true
}

enable_pack_flag(){
  local name="$1"
  enable_feature_flag "packs.${name}" "true"
}

disable_pack_flag(){
  local name="$1"
  enable_feature_flag "packs.${name}" "false"
}

enable_pack_flag(){
  local name="$1"
  enable_feature_flag "packs.${name}" "true"
}

case "$ACTION" in

  list) list_packs ;;
  show) [[ -n "${1:-}" ]] || die "Usage: packs show <name>"; show_pack "$1" ;;
enable)
  if [[ -z "${1:-}" ]]; then die "Usage: packs enable <pack> [pack2...] [--apply]"; fi
  want=()
  for a in "$@"; do [[ "$a" == "--apply" ]] && continue; want+=("$a"); done
  mapfile -t ordered < <(resolve_deps "${want[@]}")
  log "Enable order: ${ordered[*]}"
  for p in "${ordered[@]}"; do
    enable_pack_flag "$p"
    install_pack "$p"
    if [[ "$APPLY" -ne 1 ]]; then
      log "DRYRUN ./bin/beast nodes install --pack=$p --apply"
    else
      "$BASE_DIR/bin/beast" nodes install --pack="$p" --apply || true
    fi
  done
  if [[ -f "$BASE_DIR/config/features.local.yml" ]]; then
    if [[ "$APPLY" -ne 1 ]]; then
      log "DRYRUN would merge features + sync features.env"
    else
      "$BASE_DIR/scripts/83_features_merge.sh" --apply
      "$BASE_DIR/scripts/13_features_sync.sh" --apply
    fi
  fi
  ;;
install)
    if [[ "${1:-}" == "all" || -z "${1:-}" ]]; then
      need_cmd jq
      mapfile -t names < <(jq -r '.packs | keys[]' "$cfg")
      for n in "${names[@]}"; do install_pack "$n"; done
    else
want=()
for a in "$@"; do [[ "$a" == "--apply" ]] && continue; want+=("$a"); done
mapfile -t ordered < <(resolve_deps "${want[@]}")
for n in "${ordered[@]}"; do

        [[ "$n" == "--apply" ]] && continue
        install_pack "$n"
      done
    fi
    # After writes to features.local.yml, merge and sync features.env
    if [[ -f "$BASE_DIR/config/features.local.yml" ]]; then
      if [[ "$APPLY" -ne 1 ]]; then
        log "DRYRUN would merge features.local.yml into features.yml (non-destructive) and sync features.env"
      else
        "$BASE_DIR/scripts/83_features_merge.sh" --apply
        "$BASE_DIR/scripts/13_features_sync.sh" --apply
      fi
    fi
    ;;
  *)
    die "Usage: packs {list|show|install} [name|all] [--apply]"
    ;;
esac
