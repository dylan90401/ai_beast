<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>AI Beast Control Room</title>
  <style>
    :root {
      --bg-1: #0b1014;
      --bg-2: #162325;
      --card: #131b1f;
      --card-2: #192328;
      --ink: #f2f0ea;
      --muted: #9fb2b0;
      --accent: #f2a154;
      --accent-2: #39d0aa;
      --danger: #ff7a7a;
      --ok: #35d399;
      --border: rgba(255,255,255,0.12);
      --shadow: 0 22px 60px rgba(6,10,14,0.55);
      --glow: 0 0 0 1px rgba(255,255,255,0.08), 0 0 32px rgba(242,161,84,0.12);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Outfit", "Sora", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 800px at -10% -20%, rgba(58, 124, 122, 0.35), transparent 60%),
        radial-gradient(900px 700px at 100% -10%, rgba(166, 132, 88, 0.4), transparent 55%),
        linear-gradient(145deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    header {
      padding: 32px 28px 8px;
      display: grid;
      gap: 14px;
    }

    h1 {
      margin: 0;
      font-size: clamp(30px, 4vw, 48px);
      letter-spacing: -0.03em;
      text-transform: uppercase;
    }

    .sub {
      color: var(--muted);
      max-width: 840px;
      line-height: 1.6;
    }

    .wrap {
      padding: 0 24px 48px;
      display: grid;
      gap: 20px;
    }

    .grid {
      display: grid;
      gap: 18px;
    }

    .grid.two { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .grid.three { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }

    .card {
      background: linear-gradient(160deg, var(--card), var(--card-2));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 20px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
      animation: rise 0.6s ease both;
      animation-delay: var(--delay, 0ms);
    }

    .card::after {
      content: "";
      position: absolute;
      top: -80px;
      right: -80px;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
      pointer-events: none;
    }

    .card h3 {
      margin: 0 0 12px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--accent);
    }

    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .spacer { flex: 1 1 auto; }
    .chip { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); color: var(--muted); font-size: 12px; }

    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .btn {
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--ink);
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04);
    }

    .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.2); }
    .btn.primary { background: linear-gradient(135deg, var(--accent), #f7c07d); color: #1b1b1b; box-shadow: var(--glow); }
    .btn.ghost { background: transparent; }

    .token-input {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(9,12,16,0.5);
      color: var(--ink);
      min-width: 260px;
      flex: 1 1 260px;
    }

    textarea.token-input { resize: vertical; min-height: 110px; }

    .muted { color: var(--muted); font-size: 13px; }
    .stat { font-size: 22px; font-weight: 700; }
    .ok { color: var(--ok); }
    .bad { color: var(--danger); }

    .tool-list { display: grid; gap: 12px; }
    .tool {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
      background: rgba(8,12,16,0.5);
      display: grid;
      gap: 8px;
    }

    .tool-header { display: flex; gap: 10px; align-items: center; }
    .tool-title { font-weight: 700; font-size: 16px; }
    .tool-desc { color: var(--muted); font-size: 13px; line-height: 1.4; }
    .tool-links { display: flex; flex-wrap: wrap; gap: 8px; }

    .link {
      color: var(--accent-2);
      text-decoration: none;
      font-size: 13px;
    }

    .toggle {
      position: relative;
      width: 46px;
      height: 26px;
    }

    .toggle input { opacity: 0; width: 0; height: 0; }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.2);
      border-radius: 999px;
      transition: 0.2s;
    }

    .slider::before {
      content: "";
      position: absolute;
      height: 20px;
      width: 20px;
      left: 3px;
      top: 3px;
      background: #0b1220;
      border-radius: 50%;
      transition: 0.2s;
    }

    .toggle input:checked + .slider { background: var(--accent-2); }
    .toggle input:checked + .slider::before { transform: translateX(20px); }

    .terminal {
      background: #0a0f14;
      border-radius: 14px;
      padding: 14px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      font-size: 12px;
      color: #cfe8de;
      max-height: 260px;
      overflow: auto;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(6, 10, 16, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 99;
    }

    .modal-card {
      width: min(920px, 92vw);
      background: linear-gradient(160deg, var(--card), var(--card-2));
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 18px;
    }

    .hero-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .hero-chip {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    @keyframes rise {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (prefers-reduced-motion: reduce) {
      .card { animation: none; }
      .btn:hover { transform: none; }
    }
  </style>
</head>
<body>
  <header>
    <h1>AI Beast Control Room</h1>
    <div class="sub">One panel for the entire stack. Toggle packs and extensions, launch every service, configure tool runners, and validate capability health across the estate.</div>
    <div class="hero-bar">
      <span class="hero-chip">Agent-ready tools</span>
      <span class="hero-chip">Ollama + Open WebUI</span>
      <span class="hero-chip">Local + Docker runners</span>
    </div>
  </header>

  <div class="wrap">
    <section id="banner" class="card" style="--delay: 20ms; display:none;">
      <div class="row">
        <div id="bannerText" class="muted">Status</div>
        <div class="spacer"></div>
        <button class="btn ghost" onclick="clearBanner()">Dismiss</button>
      </div>
    </section>
    <section class="card" style="--delay: 50ms;">
      <div class="row">
        <div>
          <div class="muted">Dashboard Token</div>
          <input id="token" class="token-input" placeholder="Paste dashboard token" />
        </div>
        <button class="btn" onclick="saveToken()">Save</button>
        <button class="btn ghost" onclick="refreshAll()">Refresh</button>
        <div class="spacer"></div>
        <div id="health" class="pill">checking...</div>
      </div>
    </section>

    <section class="card" style="--delay: 90ms;">
      <div class="row" style="gap: 12px;">
        <div>
          <div class="muted">Hugging Face Token (optional)</div>
          <input id="hfToken" class="token-input" placeholder="hf_xxx (leave blank to clear)" />
          <div class="muted" style="margin-top:6px;">Needed only for gated/private models in Open WebUI.</div>
        </div>
        <button class="btn" onclick="saveHfToken()">Save HF Token</button>
        <button class="btn ghost" onclick="clearHfToken()">Clear</button>
        <div class="spacer"></div>
        <div id="hfStatus" class="pill">checking...</div>
      </div>
    </section>

    <section class="grid two">
      <div class="card" style="--delay: 120ms;">
        <h3>System</h3>
        <div id="systemMetrics" class="tool-list"></div>
      </div>
      <div class="card" style="--delay: 180ms;">
        <h3>Actions</h3>
        <div class="row">
          <button class="btn" onclick="runCmd('preflight')">Preflight</button>
          <button class="btn" onclick="runCmd('status')">Status</button>
          <button class="btn" onclick="runCmd('doctor')">Doctor</button>
          <button class="btn" onclick="runCmd('compose_gen')">Compose Gen</button>
          <button class="btn" onclick="runCmd('up')">Up</button>
          <button class="btn" onclick="runCmd('down')">Down</button>
          <button class="btn" onclick="runCmd('speech_up')">Speech Up</button>
          <button class="btn" onclick="runCmd('speech_down')">Speech Down</button>
        </div>
        <div class="muted" style="margin-top:10px;">All commands run via <code>bin/beast</code> on the host.</div>
      </div>
    </section>

    <section class="card" style="--delay: 190ms;">
      <h3>Storage Paths</h3>
      <div class="muted" style="margin-bottom: 8px;">Update GUTS/HEAVY storage locations (re-runs init and creates dirs).</div>
      <div class="row" style="gap: 10px; margin-bottom: 10px;">
        <input id="gutsDir" class="token-input" placeholder="GUTS_DIR (internal, apps/venv)" />
        <input id="heavyDir" class="token-input" placeholder="HEAVY_DIR (external, models/data)" />
      </div>
      <div class="row">
        <button class="btn primary" onclick="savePaths()">Save Paths</button>
        <span id="pathsStatus" class="pill">idle</span>
      </div>
    </section>

    <section class="card" style="--delay: 195ms;">
      <h3>LLM Models</h3>
      <div class="row" style="margin-bottom: 12px;">
        <button class="btn" onclick="refreshModels()">ðŸ”„ Scan Models</button>
        <button class="btn" onclick="showOllamaLibrary()">ðŸ“¦ Ollama Library</button>
        <button class="btn" onclick="showUrlDownload()">ðŸ”— Download from URL</button>
        <div class="spacer"></div>
        <span id="ollamaStatus" class="pill">checking...</span>
      </div>
      <div id="urlDownloadPanel" style="display:none; margin-bottom: 12px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 12px;">
        <div class="muted" style="margin-bottom: 8px;">Download model from URL (Hugging Face, direct links, etc.)</div>
        <div class="row" style="gap: 8px;">
          <input id="modelUrl" type="text" class="token-input" placeholder="https://huggingface.co/.../model.gguf" style="flex: 2;">
          <select id="modelDestination" class="token-input" style="flex: 0 0 120px;">
            <option value="internal">Internal</option>
            <option value="external">External</option>
            <option value="custom">Custom</option>
          </select>
          <button class="btn primary" onclick="downloadFromUrl()">Download</button>
        </div>
        <input id="customPath" type="text" class="token-input" placeholder="Custom path (if selected)" style="display:none; margin-top: 8px; width: 100%;">
      </div>
      <div id="ollamaLibrary" style="display:none; margin-bottom: 12px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 12px; max-height: 300px; overflow-y: auto;">
        <div class="muted" style="margin-bottom: 8px;">Popular Ollama models (click to pull)</div>
        <div id="ollamaLibraryList" class="row" style="flex-wrap: wrap; gap: 6px;"></div>
      </div>
      <div id="downloadProgress" style="display:none; margin-bottom: 12px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 12px;">
        <div class="row">
          <span id="downloadName">Downloading...</span>
          <div class="spacer"></div>
          <span id="downloadPercent">0%</span>
        </div>
        <div style="height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; margin-top: 8px;">
          <div id="downloadBar" style="height: 100%; width: 0%; background: var(--accent); border-radius: 4px; transition: width 0.3s;"></div>
        </div>
      </div>
      <div id="modelList" class="tool-list"></div>
      <div style="margin-top: 12px;">
        <div class="muted" style="margin-bottom: 6px;">Model Registry (versioned)</div>
        <div id="modelRegistryList" class="tool-list"></div>
      </div>
      <div id="storageInfo" class="muted" style="margin-top: 12px;"></div>
    </section>

    <section class="card" style="--delay: 225ms;">
      <h3>Segments</h3>
      <div class="muted" style="margin-bottom:8px;">Toggle bundles of packs/extensions for common workflows.</div>
      <div id="segmentList" class="tool-list"></div>
    </section>

    <section class="card" style="--delay: 210ms;">
      <h3>Capabilities</h3>
      <div id="capabilityList" class="tool-list"></div>
    </section>

    <section class="card" style="--delay: 230ms;">
      <h3>Capability Validation</h3>
      <div class="row" style="margin-bottom: 10px;">
        <button class="btn primary" onclick="runCapabilityChecks()">Run Checks</button>
        <span id="capCheckStatus" class="pill">idle</span>
        <label class="row" style="gap: 6px; align-items: center; margin-left: 12px;">
          <input id="capAllowToolRuns" type="checkbox">
          <span class="muted">Allow tool checks</span>
        </label>
      </div>
      <div id="capCheckResults" class="tool-list"></div>
    </section>

    <section class="card" style="--delay: 232ms;">
      <h3>Agent & WebUI Tools</h3>
      <div class="muted" style="margin-bottom: 10px;">These tools are available to the agent via `ai_tool_run` and can be exported to other tool-capable UIs.</div>
      <div class="row">
        <button class="btn" onclick="showToolManifest()">View Manifest</button>
        <button class="btn ghost" onclick="copyToolManifest()">Copy Manifest</button>
      </div>
    </section>

    <section class="card" style="--delay: 234ms;">
      <h3>Queue (RQ)</h3>
      <div class="muted" style="margin-bottom: 8px;">Enqueue tasks for background workers. Only tasks in <code>modules.queue.tasks</code> are allowed.</div>
      <div class="row" style="gap: 8px; margin-bottom: 8px;">
        <input id="queueTask" class="token-input" placeholder="modules.queue.tasks.heartbeat" style="flex: 2;">
        <button class="btn" onclick="enqueueHeartbeat()">Heartbeat</button>
        <button class="btn primary" onclick="enqueueQueueTask()">Enqueue</button>
      </div>
      <textarea id="queuePayload" class="token-input" placeholder='{"args":["hello"],"kwargs":{}}' style="width: 100%; min-height: 70px;"></textarea>
      <div class="row" style="margin-top: 10px; gap: 8px;">
        <select id="queueStatusFilter" class="token-input" style="max-width: 180px;" onchange="loadQueueJobs()">
          <option value="">All</option>
          <option value="queued">Queued</option>
          <option value="started">Started</option>
          <option value="finished">Finished</option>
          <option value="failed">Failed</option>
        </select>
        <button class="btn ghost" onclick="loadQueueJobs()">Refresh Jobs</button>
        <button class="btn ghost" onclick="cleanupQueueJobs('finished')">Clear Finished</button>
        <button class="btn ghost" onclick="cleanupQueueJobs('failed')">Clear Failed</button>
        <button class="btn ghost" onclick="cleanupQueueJobs('queued')">Clear Queued</button>
      </div>
      <div id="queueJobList" class="tool-list" style="margin-top: 8px;"></div>
    </section>

    <section class="card" style="--delay: 235ms;">
      <h3>AI Tools (Archives)</h3>
      <div class="muted" style="margin-bottom: 8px;">Tooling archives from `_ai_tools` with quick extract actions.</div>
      <div class="row" style="margin-bottom: 8px;">
        <select id="aiToolPicker" class="token-input" style="flex: 1 1 240px;"></select>
        <button class="btn" onclick="installSelectedTool(false)">Extract Selected</button>
        <button class="btn" onclick="installSelectedTool(true)">Install Selected</button>
        <button class="btn ghost" onclick="installAllTools()">Install All (run)</button>
      </div>
      <div class="row" style="margin-bottom: 8px;">
        <select id="aiToolRunPicker" class="token-input" style="flex: 1 1 200px;" onchange="updateAiToolRunner()"></select>
        <select id="aiToolEntry" class="token-input" style="flex: 1 1 240px;"></select>
        <input id="aiToolArgs" class="token-input" style="flex: 1 1 260px;" placeholder="args (optional)"/>
        <button class="btn" onclick="runAiTool()">Run Tool</button>
      </div>
      <label class="row" style="gap: 6px; align-items: center; margin-bottom: 8px;">
        <input id="toolAllowRun" type="checkbox">
        <span class="muted">Allow tool runs (unsandboxed)</span>
      </label>
      <div id="aiToolEntryHint" class="muted" style="margin-bottom: 8px;"></div>
      <div id="aiToolsList" class="tool-list"></div>
    </section>

    <section class="grid two">
      <div class="card" style="--delay: 240ms;">
        <h3>Packs</h3>
        <div id="packList" class="tool-list"></div>
      </div>
      <div class="card" style="--delay: 300ms;">
        <h3>Extensions</h3>
        <div id="extensionList" class="tool-list"></div>
      </div>
    </section>

    <section class="card" style="--delay: 360ms;">
      <h3>Services & Ports</h3>
      <div id="serviceList" class="tool-list"></div>
    </section>

    <section class="card" style="--delay: 390ms;">
      <h3>Colima Container Logs</h3>
      <div class="row" style="margin-bottom: 10px;">
        <select id="dockerContainer" class="token-input" style="flex: 1 1 240px;"></select>
        <input id="dockerTail" class="token-input" style="max-width: 120px;" value="200" />
        <button class="btn" onclick="refreshDockerLogs()">Refresh Logs</button>
      </div>
      <div class="row" style="margin-bottom: 6px;">
        <label class="row" style="gap: 6px;">
          <input id="dockerFilterAiBeast" type="checkbox" checked />
          <span class="muted">Only ai_beast_*</span>
        </label>
        <label class="row" style="gap: 6px;">
          <input id="dockerAutoRefresh" type="checkbox" />
          <span class="muted">Auto refresh</span>
        </label>
        <input id="dockerRefreshMs" class="token-input" style="max-width: 120px;" value="5000" />
        <span class="muted">ms</span>
        <label class="row" style="gap: 6px;">
          <input id="dockerAutoScroll" type="checkbox" checked />
          <span class="muted">Auto scroll</span>
        </label>
      </div>
      <div class="row" style="margin-bottom: 6px;">
        <input id="dockerSearch" class="token-input" placeholder="Filter logs..." />
        <button class="btn ghost" onclick="clearDockerSearch()">Clear</button>
      </div>
      <div id="dockerQuick" class="row" style="flex-wrap: wrap; gap: 6px; margin-bottom: 6px;"></div>
      <div id="dockerStatus" class="muted">loading containers...</div>
      <div id="dockerLogs" class="terminal" style="margin-top: 10px; max-height: 320px;">Waiting for selection.</div>
    </section>

    <section class="card" style="--delay: 420ms;">
      <h3>Command Output</h3>
      <div id="log" class="terminal">Ready.</div>
    </section>
  </div>

  <div id="modal" class="modal" style="display:none;">
    <div class="modal-card">
      <div class="row">
        <div class="tool-title">Console Output</div>
        <div class="spacer"></div>
        <button class="btn ghost" onclick="closeModal()">Close</button>
      </div>
      <div id="modalBody" class="terminal" style="margin-top: 10px; max-height: 60vh;">...</div>
    </div>
  </div>

  <div id="toolConfigModal" class="modal" style="display:none;">
    <div class="modal-card">
      <div class="row">
        <div class="tool-title">Tool Configuration</div>
        <div class="spacer"></div>
        <button class="btn ghost" onclick="closeToolConfig()">Close</button>
      </div>
      <div class="grid two" style="margin-top: 12px;">
        <div>
          <div class="muted">Tool</div>
          <input id="toolCfgName" class="token-input" disabled />
        </div>
        <div>
          <div class="muted">Runner</div>
          <select id="toolCfgRunner" class="token-input" onchange="updateToolRunnerFields()">
            <option value="local">Local</option>
            <option value="docker">Docker</option>
            <option value="compose">Compose</option>
          </select>
        </div>
        <div class="grid" style="grid-column: 1 / -1; gap: 8px;">
          <div class="muted">Description</div>
          <input id="toolCfgDesc" class="token-input" placeholder="Short description" />
        </div>
        <div>
          <div class="muted">Entrypoint</div>
          <select id="toolCfgEntry" class="token-input"></select>
        </div>
        <div>
          <div class="muted">Entrypoint Override</div>
          <input id="toolCfgEntryCustom" class="token-input" placeholder="e.g. bin/nmap" />
        </div>
        <div>
          <div class="muted">Args</div>
          <input id="toolCfgArgs" class="token-input" placeholder="--help" />
        </div>
        <div>
          <div class="muted">Working Dir</div>
          <input id="toolCfgCwd" class="token-input" placeholder="/absolute/path or relative" />
        </div>
        <div class="grid" style="grid-column: 1 / -1; gap: 8px;">
          <div class="muted">Env (KEY=VALUE per line)</div>
          <textarea id="toolCfgEnv" class="token-input" rows="4" placeholder="API_KEY=...\nCONFIG=..."></textarea>
        </div>
        <div>
          <div class="muted">Test Command</div>
          <input id="toolCfgTestCommand" class="token-input" placeholder="nmap --version" />
        </div>
        <div>
          <div class="muted">Test URL</div>
          <input id="toolCfgTestUrl" class="token-input" placeholder="http://127.0.0.1:8080/health" />
        </div>
        <div id="toolCfgDockerBlock" style="display:none;">
          <div class="muted">Docker Image</div>
          <input id="toolCfgDockerImage" class="token-input" placeholder="repo/image:tag" />
          <div class="muted" style="margin-top: 8px;">Docker Args</div>
          <input id="toolCfgDockerArgs" class="token-input" placeholder="--network host" />
        </div>
        <div id="toolCfgComposeBlock" style="display:none;">
          <div class="muted">Compose Service</div>
          <input id="toolCfgComposeService" class="token-input" placeholder="service_name" />
          <div class="muted" style="margin-top: 8px;">Compose File</div>
          <input id="toolCfgComposeFile" class="token-input" placeholder="docker-compose.yml" />
        </div>
      </div>
      <div class="row" style="margin-top: 16px;">
        <button class="btn primary" onclick="saveToolConfig()">Save Config</button>
        <button class="btn" onclick="testToolFromModal()">Test Tool</button>
        <button class="btn ghost" onclick="runToolFromModal()">Run Tool</button>
        <div class="spacer"></div>
        <span id="toolCfgStatus" class="pill">idle</span>
      </div>
    </div>
  </div>

<script>
  const state = {
    token: localStorage.getItem('beast_token') || '',
    config: {},
    packs: [],
    extensions: [],
    metrics: {},
    hfSet: false,
    capabilities: [],
    capabilityActions: {},
    dockerContainers: [],
    dockerLogRaw: '',
    aiTools: [],
    toolConfig: null,
  };

  const MODAL_AUTO_OPEN = true;
  const MODAL_AUTO_CLOSE_MS = 8000;

  let dockerTimer = null;
  let bannerTimer = null;
  let modalTimer = null;

  function openModal(text, autoCloseMs = MODAL_AUTO_CLOSE_MS) {
    const modal = document.getElementById('modal');
    const body = document.getElementById('modalBody');
    if (body) body.textContent = text || '';
    if (modal) modal.style.display = 'flex';
    if (modalTimer) {
      clearTimeout(modalTimer);
      modalTimer = null;
    }
    if (autoCloseMs && autoCloseMs > 0) {
      modalTimer = setTimeout(() => closeModal(), autoCloseMs);
    }
  }

  function closeModal() {
    const modal = document.getElementById('modal');
    if (modal) modal.style.display = 'none';
    if (modalTimer) {
      clearTimeout(modalTimer);
      modalTimer = null;
    }
  }

  function setLog(text, options = {}) {
    const log = document.getElementById('log');
    const message = text || '';
    if (log) log.textContent = message;
    const open = options.open ?? MODAL_AUTO_OPEN;
    if (open) {
      openModal(message, options.autoCloseMs);
    }
  }

  function showBanner(message, kind = 'info', timeoutMs = 0) {
    const box = document.getElementById('banner');
    const text = document.getElementById('bannerText');
    if (!box || !text) return;
    text.textContent = message;
    box.style.display = 'block';
    box.style.borderColor = kind === 'error' ? 'rgba(255,107,107,0.6)' : 'rgba(255,255,255,0.2)';
    if (bannerTimer) clearTimeout(bannerTimer);
    if (timeoutMs > 0) {
      bannerTimer = setTimeout(() => {
        clearBanner();
      }, timeoutMs);
    }
  }

  function clearBanner() {
    const box = document.getElementById('banner');
    if (box) box.style.display = 'none';
    if (bannerTimer) {
      clearTimeout(bannerTimer);
      bannerTimer = null;
    }
  }

  const EXT_INFO = {
    dify: {
      title: 'Dify',
      description: 'Low-code agent builder stack with API + web UI.',
      ports: ['PORT_DIFY'],
      portal: cfg => url(cfg, 'PORT_DIFY'),
      api: 'internal: dify-api:5001',
    },
    flowise: {
      title: 'Flowise',
      description: 'Flow-based LLM orchestration UI.',
      ports: ['PORT_FLOWISE'],
      portal: cfg => url(cfg, 'PORT_FLOWISE'),
      api: cfg => url(cfg, 'PORT_FLOWISE'),
    },
    langflow: {
      title: 'Langflow',
      description: 'Visual builder for LLM chains and data flows.',
      ports: ['PORT_LANGFLOW'],
      portal: cfg => url(cfg, 'PORT_LANGFLOW'),
      api: cfg => url(cfg, 'PORT_LANGFLOW'),
    },
    searxng: {
      title: 'SearxNG',
      description: 'Meta-search engine for OSINT.',
      ports: ['PORT_SEARXNG'],
      portal: cfg => url(cfg, 'PORT_SEARXNG'),
      api: cfg => url(cfg, 'PORT_SEARXNG'),
    },
    jupyter: {
      title: 'JupyterLab',
      description: 'Notebook-based code runner and analysis.',
      ports: ['PORT_JUPYTER'],
      portal: cfg => url(cfg, 'PORT_JUPYTER', 'lab'),
      api: cfg => url(cfg, 'PORT_JUPYTER', 'api'),
    },
    apache_tika: {
      title: 'Apache Tika',
      description: 'Document parsing and normalization.',
      ports: ['PORT_TIKA'],
      portal: cfg => url(cfg, 'PORT_TIKA'),
      api: cfg => url(cfg, 'PORT_TIKA'),
    },
    unstructured_api: {
      title: 'Unstructured API',
      description: 'Document chunking and preprocessing.',
      ports: ['PORT_UNSTRUCTURED'],
      portal: cfg => url(cfg, 'PORT_UNSTRUCTURED'),
      api: cfg => url(cfg, 'PORT_UNSTRUCTURED'),
    },
    otel_collector: {
      title: 'OTel Collector',
      description: 'Telemetry collection pipeline.',
      ports: ['PORT_OTEL_GRPC', 'PORT_OTEL_HTTP'],
      portal: null,
      api: cfg => `http://${bind(cfg)}:${port(cfg, 'PORT_OTEL_HTTP', 4318)}`,
    },
    minio: {
      title: 'MinIO',
      description: 'S3-compatible object storage.',
      ports: ['PORT_MINIO', 'PORT_MINIO_CONSOLE'],
      portal: cfg => `http://${bind(cfg)}:${port(cfg, 'PORT_MINIO_CONSOLE', 9002)}`,
      api: cfg => `http://${bind(cfg)}:${port(cfg, 'PORT_MINIO', 9001)}`,
    },
    comfyui_manager: {
      title: 'ComfyUI Manager',
      description: 'ComfyUI custom node manager (native add-on).',
      ports: [],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: null,
    },
    comfyui_video: {
      title: 'ComfyUI Video',
      description: 'Video pipeline nodes for ComfyUI.',
      ports: [],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: null,
    },
    example_service: { title: 'Example Service', description: 'Example extension service.', ports: [], portal: null, api: null },
    example_segment: { title: 'Example Segment', description: 'Example segment extension.', ports: [], portal: null, api: null },
  };

  const AI_TOOL_INFO = {
    "aircrack-ng": { title: "Aircrack-ng", desc: "Wireless security suite.", help: "https://www.aircrack-ng.org/" },
    "beef": { title: "BeEF", desc: "Browser exploitation framework.", help: "https://github.com/beefproject/beef" },
    "burp-suite": { title: "Burp Suite", desc: "Web security testing toolkit.", help: "https://portswigger.net/burp" },
    "cobalt-strike": { title: "Cobalt Strike", desc: "Red team adversary simulation.", help: "https://www.cobaltstrike.com/" },
    "core-impact": { title: "Core Impact", desc: "Commercial penetration testing suite.", help: "https://www.coresecurity.com/products/core-impact" },
    "dsniff": { title: "dsniff", desc: "Network sniffing/utilities.", help: "https://www.monkey.org/~dugsong/dsniff/" },
    "empire": { title: "Empire", desc: "Post-exploitation framework.", help: "https://github.com/BC-SECURITY/Empire" },
    "ettercap": { title: "Ettercap", desc: "MITM and network analysis tool.", help: "https://www.ettercap-project.org/" },
    "impacket": { title: "Impacket", desc: "Network protocols/AD tooling.", help: "https://github.com/fortra/impacket" },
    "john-the-ripper": { title: "John the Ripper", desc: "Password auditing tool.", help: "https://www.openwall.com/john/" },
    "nessus": { title: "Nessus", desc: "Vulnerability scanner.", help: "https://www.tenable.com/products/nessus" },
    "netcat": { title: "Netcat", desc: "Network Swiss Army knife.", help: "https://nc110.sourceforge.io/" },
    "nmap": { title: "Nmap", desc: "Network discovery and security scanning.", help: "https://nmap.org/" },
    "power-sploit": { title: "PowerSploit", desc: "PowerShell post-exploitation.", help: "https://github.com/PowerShellMafia/PowerSploit" },
    "powershell-empire": { title: "PowerShell Empire", desc: "Legacy Empire variant.", help: "https://github.com/EmpireProject/Empire" },
    "sharp-shooter": { title: "SharpShooter", desc: "Payload generation framework.", help: "https://github.com/mdsecactivebreach/SharpShooter" },
    "sqlmap": { title: "sqlmap", desc: "SQL injection automation.", help: "https://sqlmap.org/" },
    "sqlninja": { title: "SQLNinja", desc: "SQL Server injection tool.", help: "https://github.com/xxgrunge/sqlninja" },
    "wireshark": { title: "Wireshark", desc: "Network protocol analyzer.", help: "https://www.wireshark.org/" },
  };

  const CORE_SERVICES = [
    { name: 'Open WebUI', port: 'PORT_WEBUI', path: '', api: '/health', desc: 'LLM web interface.' },
    { name: 'Ollama API', port: 'PORT_OLLAMA', path: '/api/version', api: '/api/version', desc: 'Local model API.' },
    { name: 'Qdrant', port: 'PORT_QDRANT', path: '', api: '/healthz', desc: 'Vector database.' },
    { name: 'ComfyUI', port: 'PORT_COMFYUI', path: '', api: '', desc: 'Image pipeline UI.' },
    { name: 'n8n', port: 'PORT_N8N', path: '', api: '', desc: 'Workflow automation.' },
    { name: 'JupyterLab', port: 'PORT_JUPYTER', path: '/lab', api: '/api', desc: 'Code runner + notebooks.' },
    { name: 'Uptime Kuma', port: 'PORT_KUMA', path: '', api: '', desc: 'Status/monitoring UI.' },
    { name: 'Speech API', port: 'PORT_SPEECH_API', path: '/docs', api: '/docs', desc: 'Local speech (STT/TTS) API.' },
  ];

  const SEGMENTS = [
    {
      id: 'research_station',
      title: 'Research Station',
      description: 'OSINT + notebooks + RAG prep stack.',
      packs: ['networking', 'osint', 'dataviz_ml', 'research_hegel_esoteric'],
      extensions: ['searxng'],
    },
    {
      id: 'media_lab',
      title: 'Media Lab',
      description: 'Textâ†’image/video/audio tooling.',
      packs: ['media_synth', 'speech_stack'],
      extensions: ['comfyui_video'],
    },
    {
      id: 'ops_observability',
      title: 'Ops & Observability',
      description: 'Net/sec + telemetry + artifact store.',
      packs: ['networking', 'defsec', 'observability_otel', 'artifact_store_minio'],
      extensions: ['otel_collector', 'minio', 'uptime_kuma'],
    },
    {
      id: 'agent_builders',
      title: 'Agent Builders',
      description: 'Low-code agent builder trio.',
      packs: ['agent_builders'],
      extensions: ['langflow', 'flowise', 'dify'],
    },
    {
      id: 'rag_ingest',
      title: 'RAG Ingest',
      description: 'Parsing + chunking pipeline.',
      packs: ['rag_ingest_pro'],
      extensions: ['apache_tika', 'unstructured_api'],
    },
  ];

  const CAPABILITIES = [
    {
      id: 'text2image',
      title: 'Text â†’ Image',
      description: 'Generate images with ComfyUI workflows.',
      packs: ['media_synth'],
      extensions: ['comfyui_manager'],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: cfg => url(cfg, 'PORT_COMFYUI', 'object_info'),
      health: cfg => url(cfg, 'PORT_COMFYUI', ''),
      ports: ['PORT_COMFYUI'],
      notes: 'Requires ComfyUI models; install separately.',
      actions: [
        { label: 'Open ComfyUI', onclick: 'openUrl(url(state.config, \"PORT_COMFYUI\"))' },
        { label: 'Workflows', onclick: 'openUrl(url(state.config, \"PORT_COMFYUI\", \"\"))' },
      ],
    },
    {
      id: 'text2video',
      title: 'Text â†’ Video',
      description: 'Video generation via ComfyUI + VideoHelperSuite nodes.',
      packs: ['media_synth'],
      extensions: ['comfyui_video'],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: cfg => url(cfg, 'PORT_COMFYUI', 'object_info'),
      health: cfg => url(cfg, 'PORT_COMFYUI', ''),
      ports: ['PORT_COMFYUI'],
      notes: 'Enable ComfyUI Video extension and install video workflows.',
      actions: [
        { label: 'Open ComfyUI', onclick: 'openUrl(url(state.config, \"PORT_COMFYUI\"))' },
      ],
    },
    {
      id: 'text2audio',
      title: 'Text â†’ Audio',
      description: 'Speech synthesis via the local Speech API.',
      packs: ['speech_stack'],
      extensions: [],
      portal: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      api: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      health: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      ports: ['PORT_SPEECH_API'],
      notes: 'Start the service with the Speech Up action.',
      actions: [
        { label: 'Start Speech', onclick: "runCmd('speech_up')" },
        { label: 'Stop Speech', onclick: "runCmd('speech_down')" },
      ],
    },
    {
      id: 'text2music',
      title: 'Text â†’ Music',
      description: 'Use speech + audio tooling for music prompts (models required).',
      packs: ['media_synth', 'speech_stack'],
      extensions: [],
      portal: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      api: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      health: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      ports: ['PORT_SPEECH_API'],
      notes: 'Needs a music-capable model + workflow.',
      actions: [
        { label: 'Start Speech', onclick: "runCmd('speech_up')" },
        { label: 'Stop Speech', onclick: "runCmd('speech_down')" },
      ],
    },
    {
      id: 'rag_search',
      title: 'RAG Search',
      description: 'Web search + retrieval foundation for RAG.',
      packs: ['osint'],
      extensions: ['searxng'],
      portal: cfg => url(cfg, 'PORT_SEARXNG'),
      api: cfg => url(cfg, 'PORT_SEARXNG'),
      health: cfg => url(cfg, 'PORT_SEARXNG'),
      ports: ['PORT_SEARXNG'],
      notes: 'SearXNG provides search; combine with Qdrant for RAG.',
      actions: [
        { label: 'Open SearXNG', onclick: 'openUrl(url(state.config, \"PORT_SEARXNG\"))' },
      ],
    },
    {
      id: 'rag_ingest',
      title: 'RAG Ingest',
      description: 'Document ingestion pipeline (Tika + Unstructured).',
      packs: ['rag_ingest_pro'],
      extensions: ['apache_tika', 'unstructured_api'],
      portal: cfg => url(cfg, 'PORT_TIKA'),
      api: cfg => url(cfg, 'PORT_UNSTRUCTURED'),
      health: cfg => url(cfg, 'PORT_TIKA'),
      ports: ['PORT_TIKA', 'PORT_UNSTRUCTURED'],
      notes: 'Enable pack to pull ingestion services.',
      actions: [
        { label: 'Open Tika', onclick: 'openUrl(url(state.config, \"PORT_TIKA\"))' },
        { label: 'Open Unstructured', onclick: 'openUrl(url(state.config, \"PORT_UNSTRUCTURED\"))' },
      ],
    },
    {
      id: 'rag_vector_db',
      title: 'Vector DB',
      description: 'Qdrant vector store for embeddings + retrieval.',
      packs: ['networking'],
      extensions: ['qdrant'],
      portal: cfg => url(cfg, 'PORT_QDRANT'),
      api: cfg => url(cfg, 'PORT_QDRANT', 'collections'),
      health: cfg => url(cfg, 'PORT_QDRANT', 'collections'),
      ports: ['PORT_QDRANT'],
      notes: 'Ensure Qdrant is running before ingest or search.',
      actions: [
        { label: 'Open Qdrant', onclick: 'openUrl(url(state.config, \"PORT_QDRANT\"))' },
      ],
    },
    {
      id: 'agent_builders',
      title: 'Agent Builders',
      description: 'Low-code builders for workflows and agents.',
      packs: ['agent_builders'],
      extensions: ['langflow', 'flowise', 'dify'],
      portal: cfg => url(cfg, 'PORT_LANGFLOW'),
      api: cfg => url(cfg, 'PORT_FLOWISE'),
      health: cfg => url(cfg, 'PORT_LANGFLOW'),
      ports: ['PORT_LANGFLOW', 'PORT_FLOWISE', 'PORT_DIFY'],
      notes: 'Enable the pack to bring up Langflow/Flowise/Dify.',
      actions: [
        { label: 'Open Langflow', onclick: 'openUrl(url(state.config, \"PORT_LANGFLOW\"))' },
        { label: 'Open Flowise', onclick: 'openUrl(url(state.config, \"PORT_FLOWISE\"))' },
        { label: 'Open Dify', onclick: 'openUrl(url(state.config, \"PORT_DIFY\"))' },
      ],
    },
    {
      id: 'code_runner',
      title: 'Code Runner',
      description: 'JupyterLab for notebooks and code execution.',
      packs: ['dataviz_ml'],
      extensions: ['jupyter'],
      portal: cfg => url(cfg, 'PORT_JUPYTER', 'lab'),
      api: cfg => url(cfg, 'PORT_JUPYTER', 'api'),
      health: cfg => url(cfg, 'PORT_JUPYTER', 'api/status'),
      ports: ['PORT_JUPYTER'],
      notes: 'Jupyter token is set in the container; open the portal to sign in.',
      actions: [
        { label: 'Open Jupyter', onclick: 'openUrl(url(state.config, \"PORT_JUPYTER\", \"lab\"))' },
      ],
    },
  ];

  const PACK_LINKS = {
    media_synth: cfg => [ { label: 'ComfyUI', url: url(cfg, 'PORT_COMFYUI') } ],
    speech_stack: cfg => [ { label: 'Speech API', url: url(cfg, 'PORT_SPEECH_API', 'docs') } ],
  };

  document.getElementById('token').value = state.token;

  function bind(cfg) {
    return cfg.AI_BEAST_BIND_ADDR || '127.0.0.1';
  }

  function port(cfg, key, fallback) {
    return cfg[key] || fallback || '';
  }

  function url(cfg, key, path='') {
    const p = port(cfg, key, '');
    if (!p) return '';
    const suffix = path ? `/${path.replace(/^\//, '')}` : '';
    return `http://${bind(cfg)}:${p}${suffix}`;
  }

  function openUrl(target) {
    if (!target) return;
    window.open(target, '_blank', 'noopener,noreferrer');
  }

  function resolveCapabilityUrl(ref) {
    if (!ref) return '';
    if (typeof ref === 'function') return ref(state.config);
    if (typeof ref === 'string') return ref;
    const portKey = ref.port || '';
    const path = ref.path || '';
    if (!portKey) return ref.url || '';
    return url(state.config, portKey, path);
  }

  async function handleCapabilityAction(capId, idx) {
    const actions = state.capabilityActions[capId] || [];
    const action = actions[idx];
    if (!action) return;
    if (action.type === 'open_url') {
      openUrl(resolveCapabilityUrl(action));
      return;
    }
    if (action.type === 'beast_cmd') {
      await runCmd(action.cmd);
      return;
    }
    if (action.type === 'tool_run') {
      await runToolAction(action);
      return;
    }
    if (action.type === 'ollama_pull') {
      const model = action.model || '';
      if (!model) {
        setLog('Missing Ollama model name.');
        return;
      }
      const res = await apiPost('/api/models/pull', { model });
      if (res.ok) {
        setLog(`Pulled model ${model}`);
      } else {
        setLog(res.error || `Failed to pull model ${model}`);
      }
      return;
    }
  }

  function saveToken() {
    state.token = document.getElementById('token').value.trim();
    localStorage.setItem('beast_token', state.token);
    showBanner('Token saved. Refreshing dashboard...', 'info', 2500);
    setLog('Token saved. Refreshing dashboard...', { autoCloseMs: 3500 });
    refreshAll();
  }

  function setHealth(ok) {
    const el = document.getElementById('health');
    el.textContent = ok ? 'online' : 'offline';
    el.className = ok ? 'pill ok' : 'pill bad';
  }

  async function apiGet(path) {
    const res = await fetch(path, {
      headers: { 'X-Beast-Token': state.token }
    });
    if (res.status === 401) {
      showBanner('Unauthorized. Paste the dashboard token and click Save.', 'error');
      return { ok: false, error: 'Unauthorized' };
    }
    if (!res.ok) {
      const text = await res.text();
      return { ok: false, error: text || `HTTP ${res.status}` };
    }
    return res.json();
  }

  async function apiPost(path, body) {
    const res = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Beast-Token': state.token,
      },
      body: JSON.stringify(body)
    });
    if (res.status === 401) {
      showBanner('Unauthorized. Paste the dashboard token and click Save.', 'error');
      return { ok: false, error: 'Unauthorized' };
    }
    if (!res.ok) {
      const text = await res.text();
      return { ok: false, error: text || `HTTP ${res.status}` };
    }
    return res.json();
  }

  async function refreshAll() {
    try {
      const health = await fetch('/api/health');
      setHealth(health.ok);
    } catch (e) {
      setHealth(false);
    }
    await Promise.allSettled([checkHfToken(), loadConfig(), loadPacks(), loadExtensions(), loadMetrics(), loadCapabilities(), refreshModels(), loadDockerContainers(), loadAiTools(), loadQueueJobs()]);
    renderServices();
    renderSegments();
    renderCapabilities();
    await checkHealth();
  }

  async function checkHfToken() {
    try {
      const data = await apiGet('/api/hf_token');
      if (data.ok) {
        state.hfSet = !!data.set;
        const badge = document.getElementById('hfStatus');
        badge.textContent = state.hfSet ? 'HF token set' : 'HF token not set';
        badge.className = state.hfSet ? 'pill ok' : 'pill bad';
      }
    } catch (e) {
      const badge = document.getElementById('hfStatus');
      badge.textContent = 'error';
      badge.className = 'pill bad';
    }
  }

  async function saveHfToken() {
    const token = document.getElementById('hfToken').value.trim();
    try {
      const res = await apiPost('/api/hf_token', { token });
      if (res.ok) {
        await checkHfToken();
        setLog(token ? 'HF token saved. Restart Open WebUI to apply.' : 'HF token cleared.');
      } else {
        setLog(res.error || 'Failed to save HF token');
      }
    } catch (e) {
      setLog('Error saving token: ' + e);
    }
  }

  async function clearHfToken() {
    document.getElementById('hfToken').value = '';
    await saveHfToken();
  }

  async function loadConfig() {
    const data = await apiGet('/api/config');
    if (data.ok) {
      state.config = data.config || {};
      renderPathsForm();
      renderMetrics();
    } else if (data.error) {
      showBanner(`Config load failed: ${data.error}`, 'error');
    }
  }

  async function loadPacks() {
    const data = await apiGet('/api/packs');
    if (data.ok) {
      state.packs = data.items || [];
      renderPacks();
    } else if (data.error) {
      showBanner(`Packs load failed: ${data.error}`, 'error');
    }
  }

  async function loadExtensions() {
    const data = await apiGet('/api/extensions');
    if (data.ok) {
      state.extensions = data.items || [];
      renderExtensions();
    } else if (data.error) {
      showBanner(`Extensions load failed: ${data.error}`, 'error');
    }
  }

  async function loadMetrics() {
    const data = await apiGet('/api/metrics');
    if (data.ok) {
      state.metrics = data.metrics || {};
      renderMetrics();
    } else if (data.error) {
      showBanner(`Metrics load failed: ${data.error}`, 'error');
    }
  }

  async function loadCapabilities() {
    const data = await apiGet('/api/capabilities');
    if (data.ok) {
      state.capabilities = data.items || [];
      renderCapabilities();
    } else if (data.error) {
      showBanner(`Capabilities load failed: ${data.error}`, 'error');
    }
  }

  async function loadAiTools() {
    const el = document.getElementById('aiToolsList');
    const picker = document.getElementById('aiToolPicker');
    const runPicker = document.getElementById('aiToolRunPicker');
    if (!el) return;
    const data = await apiGet('/api/tools');
    if (!data.ok) {
      el.innerHTML = `<div class="muted">Failed to load tools: ${data.error || 'unknown error'}</div>`;
      return;
    }
    const tools = data.tools || [];
    state.aiTools = tools;
    if (!tools.length) {
      el.innerHTML = '<div class="muted">No tool archives found.</div>';
      if (picker) picker.innerHTML = '';
      if (runPicker) runPicker.innerHTML = '';
      return;
    }
    if (picker) {
      picker.innerHTML = tools.map(t => `<option value="${t.name}">${t.name}</option>`).join('');
    }
    if (runPicker) {
      runPicker.innerHTML = tools.map(t => `<option value="${t.name}">${t.name}</option>`).join('');
    }
    updateAiToolRunner();
    el.innerHTML = tools.map(t => {
      const info = AI_TOOL_INFO[t.name] || { title: t.name, desc: 'Tool archive', help: '' };
      const cfg = t.config || {};
      const status = t.extracted === 'true' ? 'extracted' : 'archive';
      const installer = t.installer === 'true' ? 'installer' : 'no installer';
      const runner = cfg.runner || 'local';
      const entry = cfg.entrypoint || '';
      const envCount = cfg.env ? Object.keys(cfg.env).length : 0;
      const notes = [
        `runner: ${runner}`,
        entry ? `entry: ${entry}` : 'entry: unset',
        envCount ? `env: ${envCount}` : 'env: none',
      ].join(' | ');
      const actions = [
        `<button class="btn" onclick="openToolConfig('${t.name}')">Configure</button>`,
        `<button class="btn ghost" onclick="runToolTest('${t.name}')">Test</button>`,
        `<button class="btn ghost" onclick="runTool('${t.name}')">Run</button>`,
        t.extracted === 'true' ? '<span class="pill ok">installed</span>' : `<button class="btn ghost" onclick="installTool('${t.name}', false)">Extract Only</button>`,
        t.extracted === 'true' ? `<button class="btn ghost" onclick="installTool('${t.name}', true)">Run Installer</button>` : `<button class="btn ghost" onclick="installTool('${t.name}', true)">Install (run)</button>`,
        t.extracted === 'true' ? `<button class="btn ghost" onclick="openToolFolder('${t.name}')">Open Folder</button>` : '',
        info.help ? `<a class="link" href="${info.help}" target="_blank" rel="noreferrer">Help</a>` : '',
      ].filter(Boolean).join('');
      return `
        <div class="tool">
          <div class="tool-header">
            <div class="tool-title">${info.title}</div>
            <div class="spacer"></div>
            <span class="pill">${t.configured ? 'configured' : 'default'}</span>
            <span class="pill">${status}</span>
            <span class="pill">${installer}</span>
          </div>
          <div class="tool-desc">${info.desc}</div>
          <div class="muted">${notes}</div>
          <div class="tool-links">${actions}</div>
        </div>
      `;
    }).join('');
  }

  async function installTool(name, runInstaller) {
    setLog(`Installing ${name}...`, { open: false });
    const res = await apiPost('/api/tools/install', { name, run_installer: !!runInstaller });
    if (res.ok) {
      if (res.returncode !== undefined && res.returncode !== 0) {
        const msg = `Installer failed for ${name} (code ${res.returncode}).\n${res.stderr || ''}`.trim();
        setLog(msg);
      } else {
        const msg = `Installed ${name} to ${res.path}${res.installer ? `\nInstaller: ${res.installer}` : ''}`.trim();
        setLog(msg);
      }
      await loadAiTools();
    } else {
      const msg = `Install failed: ${res.error || 'unknown error'}`;
      setLog(msg);
    }
  }

  async function installAllTools() {
    setLog('Installing all tools...', { open: false });
    const res = await apiPost('/api/tools/extract_all', { run_installer: true });
    if (res.ok) {
      const failures = (res.results || []).filter(r => !r.ok);
      const msg = failures.length
        ? `Installed with ${failures.length} failures.`
        : 'All tools installed.';
      setLog(msg);
      await loadAiTools();
    } else {
      const msg = `Install all failed: ${res.error || 'unknown error'}`;
      setLog(msg);
    }
  }

  async function installSelectedTool(runInstaller) {
    const picker = document.getElementById('aiToolPicker');
    if (!picker || !picker.value) return;
    await installTool(picker.value, !!runInstaller);
  }

  async function openToolFolder(name) {
    setLog(`Opening ${name} folder...`, { open: false });
    const res = await apiPost('/api/tools/open', { name });
    if (res.ok) {
      setLog(`Opened ${name} folder.`);
    } else {
      const msg = `Open failed: ${res.error || 'unknown error'}`;
      setLog(msg);
    }
  }

  async function runToolTest(name) {
    const allow = !!(document.getElementById('toolAllowRun') || {}).checked;
    if (!allow) {
      setLog('Enable Allow tool runs to execute tests.');
      return;
    }
    setLog(`Testing ${name}...`, { open: false });
    const res = await apiPost('/api/tools/test', { name, allow });
    if (res && res.ok !== undefined) {
      const msg = res.status
        ? `Test ${name}: ${res.ok ? 'ok' : 'fail'} (${res.status})`
        : `${name} test\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
      setLog(msg || `Tested ${name}.`);
      return;
    }
    setLog(res.error || `Test failed for ${name}.`);
  }

  async function runTool(name) {
    const allow = !!(document.getElementById('toolAllowRun') || {}).checked;
    if (!allow) {
      setLog('Enable Allow tool runs to execute.');
      return;
    }
    setLog(`Running ${name}...`, { open: false });
    const res = await apiPost('/api/tools/run', { name, allow });
    const msg = `${(res.cmd || []).join(' ')}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
    if (res && res.ok !== undefined) {
      setLog(msg || `Ran ${name}.`);
      return;
    }
    setLog(res.error || `Run failed for ${name}.`);
  }

  async function runToolAction(action) {
    const allow = !!(document.getElementById('toolAllowRun') || {}).checked;
    if (!allow) {
      setLog('Enable Allow tool runs to execute.');
      return;
    }
    const payload = {
      name: action.tool || '',
      entrypoint: action.entrypoint || '',
      args: action.args || '',
      allow,
    };
    if (!payload.name) {
      setLog('Tool action missing tool name.');
      return;
    }
    setLog(`Running ${payload.name}...`, { open: false });
    const res = await apiPost('/api/tools/run', payload);
    const msg = `${(res.cmd || []).join(' ')}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
    if (res && res.ok !== undefined) {
      setLog(msg || `Ran ${payload.name}.`);
      return;
    }
    setLog(res.error || `Run failed for ${payload.name}.`);
  }

  function openToolConfig(name) {
    const modal = document.getElementById('toolConfigModal');
    if (modal) modal.style.display = 'flex';
    loadToolConfig(name);
  }

  function closeToolConfig() {
    const modal = document.getElementById('toolConfigModal');
    if (modal) modal.style.display = 'none';
  }

  function parseEnvText(raw) {
    const env = {};
    (raw || '').split('\n').forEach(line => {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) return;
      const idx = trimmed.indexOf('=');
      if (idx === -1) return;
      const key = trimmed.slice(0, idx).trim();
      const val = trimmed.slice(idx + 1).trim();
      if (key) env[key] = val;
    });
    return env;
  }

  function envToText(env) {
    if (!env) return '';
    return Object.entries(env).map(([k, v]) => `${k}=${v}`).join('\n');
  }

  async function loadToolConfig(name) {
    const data = await apiGet(`/api/tools/config?name=${encodeURIComponent(name)}`);
    if (!data.ok) {
      setLog(data.error || 'Failed to load tool config.');
      return;
    }
    const tool = data.tool || {};
    const cfg = tool.config || {};
    state.toolConfig = tool;
    document.getElementById('toolCfgName').value = tool.name || name;
    document.getElementById('toolCfgRunner').value = cfg.runner || 'local';
    document.getElementById('toolCfgDesc').value = cfg.description || '';
    const entrySelect = document.getElementById('toolCfgEntry');
    const entryOptions = (tool.entrypoints || []).slice();
    if (cfg.entrypoint && !entryOptions.includes(cfg.entrypoint)) {
      entryOptions.unshift(cfg.entrypoint);
    }
    entrySelect.innerHTML = entryOptions.map(ep => `<option value="${ep}">${ep}</option>`).join('') || '<option value="">(no entrypoints)</option>';
    entrySelect.value = cfg.entrypoint || (entryOptions[0] || '');
    document.getElementById('toolCfgEntryCustom').value = '';
    document.getElementById('toolCfgArgs').value = cfg.args || '';
    document.getElementById('toolCfgCwd').value = cfg.cwd || '';
    document.getElementById('toolCfgEnv').value = envToText(cfg.env || {});
    document.getElementById('toolCfgTestCommand').value = cfg.test_command || '';
    document.getElementById('toolCfgTestUrl').value = cfg.test_url || '';
    document.getElementById('toolCfgDockerImage').value = cfg.docker_image || '';
    document.getElementById('toolCfgDockerArgs').value = cfg.docker_args || '';
    document.getElementById('toolCfgComposeService').value = cfg.compose_service || '';
    document.getElementById('toolCfgComposeFile').value = cfg.compose_file || '';
    document.getElementById('toolCfgStatus').textContent = 'ready';
    updateToolRunnerFields();
  }

  function updateToolRunnerFields() {
    const runner = document.getElementById('toolCfgRunner').value;
    const dockerBlock = document.getElementById('toolCfgDockerBlock');
    const composeBlock = document.getElementById('toolCfgComposeBlock');
    if (dockerBlock) dockerBlock.style.display = runner === 'docker' ? 'block' : 'none';
    if (composeBlock) composeBlock.style.display = runner === 'compose' ? 'block' : 'none';
  }

  async function saveToolConfig() {
    const name = document.getElementById('toolCfgName').value.trim();
    const entrySelect = document.getElementById('toolCfgEntry').value.trim();
    const entryCustom = document.getElementById('toolCfgEntryCustom').value.trim();
    const payload = {
      name,
      config: {
        runner: document.getElementById('toolCfgRunner').value,
        description: document.getElementById('toolCfgDesc').value.trim(),
        entrypoint: entryCustom || entrySelect,
        args: document.getElementById('toolCfgArgs').value.trim(),
        cwd: document.getElementById('toolCfgCwd').value.trim(),
        env: parseEnvText(document.getElementById('toolCfgEnv').value),
        test_command: document.getElementById('toolCfgTestCommand').value.trim(),
        test_url: document.getElementById('toolCfgTestUrl').value.trim(),
        docker_image: document.getElementById('toolCfgDockerImage').value.trim(),
        docker_args: document.getElementById('toolCfgDockerArgs').value.trim(),
        compose_service: document.getElementById('toolCfgComposeService').value.trim(),
        compose_file: document.getElementById('toolCfgComposeFile').value.trim(),
      }
    };
    const res = await apiPost('/api/tools/config', payload);
    if (res.ok) {
      document.getElementById('toolCfgStatus').textContent = 'saved';
      await loadAiTools();
      setLog(`Saved config for ${name}.`);
    } else {
      document.getElementById('toolCfgStatus').textContent = 'error';
      setLog(res.error || 'Failed to save tool config.');
    }
  }

  async function testToolFromModal() {
    const name = document.getElementById('toolCfgName').value.trim();
    if (!name) return;
    await runToolTest(name);
  }

  async function runToolFromModal() {
    const name = document.getElementById('toolCfgName').value.trim();
    if (!name) return;
    await runTool(name);
  }

  async function showToolManifest() {
    const data = await apiGet('/api/tools/manifest');
    if (!data.ok) {
      setLog(data.error || 'Manifest unavailable.');
      return;
    }
    openModal(JSON.stringify(data, null, 2));
  }

  async function copyToolManifest() {
    const data = await apiGet('/api/tools/manifest');
    if (!data.ok) {
      setLog(data.error || 'Manifest unavailable.');
      return;
    }
    try {
      await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
      setLog('Tool manifest copied to clipboard.');
    } catch (e) {
      setLog(`Clipboard failed: ${e.message || e}`);
    }
  }

  function updateAiToolRunner() {
    const picker = document.getElementById('aiToolRunPicker');
    const entry = document.getElementById('aiToolEntry');
    const hint = document.getElementById('aiToolEntryHint');
    if (!picker || !entry || !hint) return;
    const tool = picker.value;
    const info = state.aiTools.find(t => t.name === tool);
    const entries = info && Array.isArray(info.entrypoints) ? info.entrypoints : [];
    if (!entries.length) {
      entry.innerHTML = '<option value="">No entrypoints found</option>';
      hint.textContent = 'Extract the tool to detect entrypoints.';
      return;
    }
    entry.innerHTML = entries.map(e => `<option value="${e}">${e}</option>`).join('');
    hint.textContent = `Detected ${entries.length} entrypoints.`;
  }

  async function runAiTool() {
    const allow = !!(document.getElementById('toolAllowRun') || {}).checked;
    if (!allow) {
      setLog('Enable Allow tool runs to execute.');
      return;
    }
    const picker = document.getElementById('aiToolRunPicker');
    const entry = document.getElementById('aiToolEntry');
    const args = document.getElementById('aiToolArgs');
    if (!picker || !entry) return;
    const tool = picker.value;
    const entrypoint = entry.value;
    if (!tool || !entrypoint) {
      setLog('Pick a tool and entrypoint before running.');
      return;
    }
    const payload = { name: tool, entrypoint, args: args ? args.value.trim() : '', allow };
    setLog(`Running ${tool}: ${entrypoint} ${payload.args}`.trim(), { open: false });
    try {
      const res = await apiPost('/api/tools/run', payload);
      if (res.ok) {
        const msg = `${(res.cmd || []).join(' ')}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
        setLog(msg || `Ran ${tool}.`);
      } else {
        setLog(res.error || 'Tool run failed.');
      }
    } catch (e) {
      setLog(`Tool run error: ${e.message || e}`);
    }
  }

  async function enqueueQueueTask() {
    const task = (document.getElementById('queueTask').value || '').trim();
    const raw = (document.getElementById('queuePayload').value || '').trim();
    if (!task) {
      setLog('Queue task is required.');
      return;
    }
    let payload = {};
    if (raw) {
      try {
        payload = JSON.parse(raw);
      } catch (e) {
        setLog('Queue payload must be valid JSON.');
        return;
      }
    }
    const res = await apiPost('/api/queue/enqueue', { task, args: payload.args || [], kwargs: payload.kwargs || {} });
    if (res.ok) {
      setLog(`Enqueued ${task} (${res.job_id || 'job'})`);
      await loadQueueJobs();
    } else {
      setLog(res.error || 'Queue enqueue failed.');
    }
  }

  async function enqueueHeartbeat() {
    const payload = { args: ["dashboard"], kwargs: { delay: 0.1 } };
    const res = await apiPost('/api/queue/enqueue', { task: 'modules.queue.tasks.heartbeat', args: payload.args, kwargs: payload.kwargs });
    if (res.ok) {
      setLog(`Heartbeat queued (${res.job_id || 'job'})`);
      await loadQueueJobs();
    } else {
      setLog(res.error || 'Queue enqueue failed.');
    }
  }

  async function loadQueueJobs() {
    const list = document.getElementById('queueJobList');
    if (!list) return;
    list.innerHTML = '<div class="muted">Loading jobs...</div>';
    const filterEl = document.getElementById('queueStatusFilter');
    const status = filterEl ? filterEl.value : '';
    const qs = new URLSearchParams({ limit: '25' });
    if (status) qs.set('status', status);
    const data = await apiGet(`/api/queue/jobs?${qs.toString()}`);
    if (!data.ok) {
      list.innerHTML = `<div class="muted">${data.error || 'Failed to load jobs'}</div>`;
      return;
    }
    const items = data.items || [];
    if (!items.length) {
      list.innerHTML = '<div class="muted">No jobs yet.</div>';
      return;
    }
    list.innerHTML = items.map(job => `
      <div class="tool">
        <div class="tool-header">
          <div class="tool-title">${job.func_name || 'task'}</div>
          <div class="spacer"></div>
          <span class="pill">${job.status || 'unknown'}</span>
          <button class="btn ghost" onclick="toggleJobDetails('${job.id}')">Details</button>
          <button class="btn ghost" onclick="retryJob('${job.id}')">Retry</button>
          <button class="btn ghost" onclick="deleteJob('${job.id}')">Delete</button>
        </div>
        <div class="tool-desc">${job.id}</div>
        <div class="muted">${job.created_at || ''}</div>
        <pre id="job-${job.id}" class="terminal" style="display:none; margin-top:8px;">${JSON.stringify({ args: job.args || [], kwargs: job.kwargs || {} }, null, 2)}</pre>
      </div>
    `).join('');
  }

  function toggleJobDetails(id) {
    const el = document.getElementById(`job-${id}`);
    if (!el) return;
    el.style.display = (el.style.display === 'none' || !el.style.display) ? 'block' : 'none';
  }

  async function retryJob(id) {
    const res = await apiPost('/api/queue/retry', { job_id: id });
    if (res.ok) {
      setLog(`Retried job ${id}`);
      await loadQueueJobs();
    } else {
      setLog(res.error || 'Retry failed.');
    }
  }

  async function deleteJob(id) {
    if (!confirm(`Delete job ${id}?`)) return;
    const res = await apiPost('/api/queue/delete', { job_id: id });
    if (res.ok) {
      setLog(`Deleted job ${id}`);
      await loadQueueJobs();
    } else {
      setLog(res.error || 'Delete failed.');
    }
  }

  async function cleanupQueueJobs(status) {
    const label = status || 'all';
    if (!confirm(`Clear ${label} jobs?`)) return;
    const res = await apiPost('/api/queue/cleanup', { status, limit: 200 });
    if (res.ok) {
      setLog(`Cleared ${res.count || 0} ${label} jobs.`);
      await loadQueueJobs();
    } else {
      setLog(res.error || 'Cleanup failed.');
    }
  }

  async function loadDockerContainers() {
    const statusEl = document.getElementById('dockerStatus');
    const selectEl = document.getElementById('dockerContainer');
    if (!statusEl || !selectEl) return;
    statusEl.textContent = 'loading containers...';
    try {
      const data = await apiGet('/api/docker/ps');
      if (data.ok) {
        state.dockerContainers = data.containers || [];
        renderDockerContainers();
      } else if (data.error) {
        showBanner(`Docker containers failed: ${data.error}`, 'error');
        statusEl.textContent = data.error || 'failed to load containers';
      } else {
        statusEl.textContent = data.error || 'failed to load containers';
      }
    } catch (e) {
      statusEl.textContent = `error: ${e.message || e}`;
    }
  }

  function renderDockerContainers() {
    const statusEl = document.getElementById('dockerStatus');
    const selectEl = document.getElementById('dockerContainer');
    const quickEl = document.getElementById('dockerQuick');
    if (!statusEl || !selectEl) return;
    const filterAi = document.getElementById('dockerFilterAiBeast');
    const onlyAi = !filterAi || filterAi.checked;
    const items = onlyAi
      ? state.dockerContainers.filter(c => c.name.startsWith('ai_beast_'))
      : state.dockerContainers;
    const current = selectEl.value;
    selectEl.innerHTML = items.map(c => `<option value="${c.name}">${c.name}</option>`).join('');
    if (current && items.some(c => c.name === current)) {
      selectEl.value = current;
    }
    statusEl.textContent = items.length ? `${items.length} containers` : 'no running containers';
    if (quickEl) {
      quickEl.innerHTML = items.map(c => {
        const label = `${c.name} (${c.status.split(' ')[0]})`;
        return `<button class="btn ghost" onclick="selectDockerContainer('${c.name}')">${label}</button>`;
      }).join('') || '<span class="muted">No containers</span>';
    }
    if (items.length) {
      refreshDockerLogs();
    } else {
      const logEl = document.getElementById('dockerLogs');
      if (logEl) logEl.textContent = 'No containers to show.';
    }
  }

  function setupDockerLogControls() {
    const selectEl = document.getElementById('dockerContainer');
    const filterEl = document.getElementById('dockerFilterAiBeast');
    const autoEl = document.getElementById('dockerAutoRefresh');
    const searchEl = document.getElementById('dockerSearch');
    const refreshMsEl = document.getElementById('dockerRefreshMs');
    if (selectEl) {
      selectEl.addEventListener('change', refreshDockerLogs);
    }
    if (filterEl) {
      filterEl.addEventListener('change', renderDockerContainers);
    }
    if (autoEl) {
      autoEl.addEventListener('change', () => {
        if (autoEl.checked) {
          const ms = parseInt((refreshMsEl && refreshMsEl.value) || '5000', 10) || 5000;
          if (dockerTimer) clearInterval(dockerTimer);
          dockerTimer = setInterval(refreshDockerLogs, ms);
          refreshDockerLogs();
        } else if (dockerTimer) {
          clearInterval(dockerTimer);
          dockerTimer = null;
        }
      });
    }
    if (searchEl) {
      searchEl.addEventListener('input', applyDockerLogFilter);
    }
    if (refreshMsEl) {
      refreshMsEl.addEventListener('change', () => {
        if (autoEl && autoEl.checked) {
          autoEl.checked = false;
          if (dockerTimer) clearInterval(dockerTimer);
          dockerTimer = null;
        }
      });
    }
  }

  async function refreshDockerLogs() {
    const selectEl = document.getElementById('dockerContainer');
    const tailEl = document.getElementById('dockerTail');
    const logEl = document.getElementById('dockerLogs');
    if (!selectEl || !logEl) return;
    const name = selectEl.value;
    const tail = parseInt((tailEl && tailEl.value) || '200', 10) || 200;
    if (!name) {
      logEl.textContent = 'No container selected.';
      return;
    }
    logEl.textContent = `Loading logs for ${name}...`;
    try {
      const data = await apiGet(`/api/docker/logs?name=${encodeURIComponent(name)}&tail=${tail}`);
      if (data.ok) {
        state.dockerLogRaw = data.logs || '';
        applyDockerLogFilter();
      } else if (data.error) {
        showBanner(`Log fetch failed: ${data.error}`, 'error');
        logEl.textContent = data.error || 'failed to load logs';
      } else {
        logEl.textContent = data.error || 'failed to load logs';
      }
    } catch (e) {
      logEl.textContent = `error: ${e.message || e}`;
    }
  }

  function applyDockerLogFilter() {
    const logEl = document.getElementById('dockerLogs');
    const queryEl = document.getElementById('dockerSearch');
    if (!logEl) return;
    const raw = state.dockerLogRaw || '';
    const q = (queryEl && queryEl.value || '').trim().toLowerCase();
    if (!q) {
      logEl.textContent = raw || '(no output)';
    } else {
      const lines = raw.split('\n').filter(line => line.toLowerCase().includes(q));
      logEl.textContent = lines.join('\n') || '(no matches)';
    }
    const autoScroll = document.getElementById('dockerAutoScroll');
    if (autoScroll && autoScroll.checked) {
      logEl.scrollTop = logEl.scrollHeight;
    }
  }

  function selectDockerContainer(name) {
    const selectEl = document.getElementById('dockerContainer');
    if (!selectEl) return;
    selectEl.value = name;
    refreshDockerLogs();
  }

  function clearDockerSearch() {
    const queryEl = document.getElementById('dockerSearch');
    if (queryEl) {
      queryEl.value = '';
    }
    applyDockerLogFilter();
  }

  function renderMetrics() {
    const el = document.getElementById('systemMetrics');
    const disk = state.metrics.disk_usage || {};
    const mem = state.metrics.memory || {};
    const db = state.metrics.metadata_db || {};
    const dbStatus = (db.ok === true) ? 'ok' : (db.ok === false ? 'down' : 'unknown');
    const rows = [
      metricRow('Base Dir', state.config.BASE_DIR || 'unknown'),
      metricRow('Guts Dir', state.config.GUTS_DIR || 'n/a'),
      metricRow('Heavy Dir', state.config.HEAVY_DIR || 'n/a'),
      metricRow('Models Dir', state.config.MODELS_DIR || 'n/a'),
      metricRow('Data Dir', state.config.DATA_DIR || 'n/a'),
      metricRow('LLM Models', state.config.LLM_MODELS_DIR || 'n/a'),
      metricRow('Ollama Models', state.config.OLLAMA_MODELS || 'n/a'),
      metricRow('Disk Used', disk.total_gb ? `${disk.used_gb} / ${disk.total_gb} GB (${disk.percent_used}%)` : 'n/a'),
      metricRow('Disk Free', disk.free_gb ? `${disk.free_gb} GB` : 'n/a'),
      metricRow('Memory Used', mem.total_gb ? `${mem.used_gb} / ${mem.total_gb} GB (${mem.percent_used}%)` : 'n/a'),
      metricRow('Metadata DB', `${db.backend || 'unknown'} (${dbStatus})`),
      metricRow('Metadata DSN', db.dsn || 'n/a'),
      metricRow('Bind Addr', bind(state.config)),
    ];
    el.innerHTML = rows.join('');
  }

  function packEnabled(name) {
    const pack = state.packs.find(p => p.name === name);
    return !!(pack && pack.enabled);
  }

  function extensionEnabled(name) {
    const ext = state.extensions.find(e => e.name === name);
    return !!(ext && ext.enabled === 'true');
  }

  function capabilityEnabled(cap) {
    if (typeof cap.enabled === 'boolean') {
      return cap.enabled;
    }
    const packsOk = (cap.packs || []).every(packEnabled);
    const extsOk = (cap.extensions || []).every(extensionEnabled);
    return packsOk && extsOk;
  }

  function segmentEnabled(seg) {
    const packsOk = (seg.packs || []).every(packEnabled);
    const extsOk = (seg.extensions || []).every(extensionEnabled);
    return packsOk && extsOk;
  }

  function renderSegments() {
    const el = document.getElementById('segmentList');
    if (!el) return;
    el.innerHTML = SEGMENTS.map(seg => {
      const enabled = segmentEnabled(seg);
      const notes = [
        seg.packs?.length ? `Packs: ${seg.packs.join(', ')}` : '',
        seg.extensions?.length ? `Extensions: ${seg.extensions.join(', ')}` : '',
      ].filter(Boolean).join(' â€¢ ');
      return toolCard({
        id: `segment-${seg.id}`,
        title: seg.title,
        description: seg.description,
        notes,
        enabled,
        onToggle: `applySegment('${seg.id}', ${!enabled})`,
        links: [],
        ports: [],
      });
    }).join('');
  }

  function renderCapabilities() {
    const el = document.getElementById('capabilityList');
    if (!el) return;
    const caps = state.capabilities.length ? state.capabilities : CAPABILITIES;
    state.capabilityActions = {};
    el.innerHTML = caps.map(cap => {
      const enabled = capabilityEnabled(cap);
      const portal = resolveCapabilityUrl(cap.portal);
      const api = resolveCapabilityUrl(cap.api);
      const health = resolveCapabilityUrl(cap.health) || api;
      const links = [];
      if (portal) links.push({ label: 'Portal', url: portal });
      if (api) links.push({ label: 'API', url: api });
      if (cap.webui) {
        const webuiPath = cap.webui.path || '';
        const webuiUrl = url(state.config, 'PORT_WEBUI', webuiPath);
        if (webuiUrl) links.push({ label: 'WebUI', url: webuiUrl });
      }
      const ports = (cap.ports || []).map(key => `${key}=${port(state.config, key, '-')}`);
      const actions = (cap.actions || []).slice();
      if (cap.ollama && cap.ollama.model) {
        const model = cap.ollama.model;
        const exists = actions.some(a => a.type === 'ollama_pull' && a.model === model);
        if (!exists) {
          actions.unshift({ label: `Pull ${model}`, type: 'ollama_pull', model });
        }
      }
      state.capabilityActions[cap.id] = actions;
      const actionsHtml = actions.map((act, idx) => {
        if (act.onclick) {
          return `<button class="btn ghost" onclick="${act.onclick}">${act.label}</button>`;
        }
        return `<button class="btn ghost" onclick="handleCapabilityAction('${cap.id}', ${idx})">${act.label}</button>`;
      }).join('');
      const integrationNotes = [];
      if (cap.webui && cap.webui.category) integrationNotes.push(`WebUI: ${cap.webui.category}`);
      if (cap.ollama && cap.ollama.model) integrationNotes.push(`Ollama: ${cap.ollama.model}`);
      if (cap.ollama && cap.ollama.embedding_model) integrationNotes.push(`Embed: ${cap.ollama.embedding_model}`);
      const notes = [cap.notes || '', ...integrationNotes].filter(Boolean).join(' â€¢ ');
      return toolCard({
        id: `cap-${cap.id}`,
        title: cap.title,
        description: cap.description,
        notes,
        enabled,
        onToggle: `toggleCapability('${cap.id}', ${!enabled})`,
        links,
        ports,
        health,
        actions: actionsHtml,
      });
    }).join('');
  }

  function setCapCheckStatus(ok, message) {
    const el = document.getElementById('capCheckStatus');
    if (!el) return;
    el.textContent = message;
    if (ok === null) {
      el.className = 'pill';
    } else if (ok) {
      el.className = 'pill ok';
    } else {
      el.className = 'pill bad';
    }
  }

  function renderCapCheckResults(results) {
    const el = document.getElementById('capCheckResults');
    if (!el) return;
    if (!results || !results.length) {
      el.innerHTML = '<div class="muted">No results yet.</div>';
      return;
    }
    el.innerHTML = results.map(r => {
      const ok = !!r.ok;
      const status = ok ? 'ok' : 'down';
      const detail = r.status ? `HTTP ${r.status}` : (r.error || 'Unknown error');
      return `
        <div class="tool">
          <div class="tool-header">
            <div class="tool-title">${r.name}</div>
            <div class="spacer"></div>
            <span class="pill ${ok ? 'ok' : 'bad'}">${status}</span>
          </div>
          <div class="tool-desc">${r.url}</div>
          <div class="muted">${detail}</div>
        </div>
      `;
    }).join('');
  }

  function metricRow(label, value) {
    return `<div class="tool"><div class="tool-header"><div class="tool-title">${label}</div><div class="spacer"></div></div><div class="tool-desc">${value}</div></div>`;
  }

  function renderPathsForm() {
    const gutsEl = document.getElementById('gutsDir');
    const heavyEl = document.getElementById('heavyDir');
    if (!gutsEl || !heavyEl) return;
    gutsEl.value = state.config.GUTS_DIR || state.config.BASE_DIR || '';
    heavyEl.value = state.config.HEAVY_DIR || '';
  }

  function setPathsStatus(ok, message) {
    const el = document.getElementById('pathsStatus');
    if (!el) return;
    el.textContent = message;
    if (ok === null) {
      el.className = 'pill';
    } else if (ok) {
      el.className = 'pill ok';
    } else {
      el.className = 'pill bad';
    }
  }

  async function savePaths() {
    const guts = (document.getElementById('gutsDir').value || '').trim();
    const heavy = (document.getElementById('heavyDir').value || '').trim();
    const payload = {};
    if (guts) payload.guts_dir = guts;
    if (heavy) payload.heavy_dir = heavy;
    if (!payload.guts_dir && !payload.heavy_dir) {
      setPathsStatus(false, 'missing');
      return;
    }
    setPathsStatus(null, 'saving...');
    try {
      const res = await apiPost('/api/paths', payload);
      if (res.ok) {
        setPathsStatus(true, 'saved');
        state.config = res.config || state.config;
        renderMetrics();
        renderPathsForm();
        setLog('Paths updated.');
      } else {
        setPathsStatus(false, 'error');
        const msg = `${res.error || 'Failed to update paths.'}\n${res.stderr || ''}`.trim();
        setLog(msg);
      }
    } catch (e) {
      setPathsStatus(false, 'error');
      setLog(`Failed to update paths: ${e.message || e}`);
    }
  }

  function renderPacks() {
    const el = document.getElementById('packList');
    if (!state.packs.length) {
      el.innerHTML = '<div class="muted">No packs found.</div>';
      return;
    }
    el.innerHTML = state.packs.map(pack => {
      const enabled = !!pack.enabled;
      const extNames = (pack.extensions || []);
      const extPorts = [];
      const links = [];
      extNames.forEach(name => {
        const meta = EXT_INFO[name];
        if (meta && meta.ports) {
          meta.ports.forEach(key => {
            const val = `${key}=${port(state.config, key, '-')}`;
            if (!extPorts.includes(val)) extPorts.push(val);
          });
        }
        if (meta) {
          const portal = typeof meta.portal === 'function' ? meta.portal(state.config) : meta.portal;
          const api = typeof meta.api === 'function' ? meta.api(state.config) : meta.api;
          if (portal) links.push({ label: `${meta.title} Portal`, url: portal });
          if (api) links.push({ label: `${meta.title} API`, url: api });
        }
      });
      if (PACK_LINKS[pack.name]) {
        links.push(...PACK_LINKS[pack.name](state.config));
      }
      const extLabel = extNames.length ? `Extensions: ${extNames.join(', ')}` : '';
      return toolCard({
        id: `pack-${pack.name}`,
        title: pack.name,
        description: pack.desc || 'No description',
        notes: [pack.notes || '', extLabel].filter(Boolean).join(' | '),
        enabled,
        onToggle: `togglePack('${pack.name}', ${!enabled})`,
        links,
        ports: extPorts,
      });
    }).join('');
  }

  function renderExtensions() {
    const el = document.getElementById('extensionList');
    if (!state.extensions.length) {
      el.innerHTML = '<div class="muted">No extensions found.</div>';
      return;
    }
    el.innerHTML = state.extensions.map(ext => {
      const meta = EXT_INFO[ext.name] || { title: ext.name, description: '', ports: [], portal: null, api: null };
      const enabled = ext.enabled === 'true';
      const canInstall = ext.has_installer === 'true';
      const links = [];
      const portal = typeof meta.portal === 'function' ? meta.portal(state.config) : meta.portal;
      const api = typeof meta.api === 'function' ? meta.api(state.config) : meta.api;
      if (portal) links.push({ label: 'Portal', url: portal });
      if (api) links.push({ label: 'API', url: api });
      const ports = (meta.ports || []).map(key => `${key}=${port(state.config, key, '-')}`);
      const actions = canInstall ? `<button class="btn" onclick="installExtension('${ext.name}')">Install</button>` : '';
      return toolCard({
        id: `ext-${ext.name}`,
        title: meta.title || ext.name,
        description: ext.description || meta.description || 'No description',
        notes: '',
        enabled,
        onToggle: `toggleExtension('${ext.name}', ${!enabled})`,
        links,
        ports,
        actions,
      });
    }).join('');
  }

  function renderServices() {
    const el = document.getElementById('serviceList');
    const items = CORE_SERVICES.map(svc => {
      const portal = url(state.config, svc.port, svc.path || '');
      const api = svc.api ? url(state.config, svc.port, svc.api) : '';
      const ports = [ `${svc.port}=${port(state.config, svc.port, '-')}` ];
      return toolCard({
        id: `svc-${svc.name}`,
        title: svc.name,
        description: svc.desc || 'Core service',
        notes: '',
        enabled: true,
        onToggle: '',
        links: [portal ? { label: 'Portal', url: portal } : null, api ? { label: 'API', url: api } : null].filter(Boolean),
        ports,
        readonly: true,
      });
    });
    el.innerHTML = items.join('');
  }

  function toolCard({ id, title, description, notes, enabled, onToggle, links, ports, readonly, health, actions }) {
    const toggle = readonly ? '' : `
      <label class="toggle">
        <input type="checkbox" ${enabled ? 'checked' : ''} onchange="${onToggle}">
        <span class="slider"></span>
      </label>`;
    const healthHtml = health ? `<span class="pill" data-health="${health}">checking</span>` : '';
    const linkHtml = (links || []).map(l => `<a class="link" href="${l.url}" target="_blank" rel="noreferrer">${l.label}</a>`).join('');
    const portHtml = (ports || []).length ? `<div class="muted">${ports.join(' | ')}</div>` : '';
    const noteHtml = notes ? `<div class="muted">${notes}</div>` : '';
    const actionsHtml = actions ? `<div class="row" style="margin-top: 8px;">${actions}</div>` : '';
    return `
      <div id="${id}" class="tool">
        <div class="tool-header">
          <div class="tool-title">${title}</div>
          <div class="spacer"></div>
          ${healthHtml}
          ${toggle}
        </div>
        <div class="tool-desc">${description}</div>
        ${noteHtml}
        ${portHtml}
        <div class="tool-links">${linkHtml || '<span class="muted">No links</span>'}</div>
        ${actionsHtml}
      </div>
    `;
  }

  async function installExtension(name) {
    setLog(`Installing extension: ${name}...`, { open: false });
    try {
      const res = await apiPost('/api/extensions/install', { name });
      const msg = `${res.cmd ? res.cmd.join(' ') : 'install'}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
      setLog(msg);
      await loadExtensions();
    } catch (e) {
      const msg = `Error: ${e.message || e}`;
      setLog(msg);
    }
  }

  async function toggleExtension(name, enable) {
    try {
      const res = await apiPost('/api/toggle', { kind: 'extension', name, enable });
      if (!res.ok) {
        const msg = `${res.error || 'Toggle failed'}\n${res.stderr || ''}`.trim();
        setLog(msg);
      } else {
        setLog(`Extension ${name} ${enable ? 'enabled' : 'disabled'}.`);
      }
    } catch (e) {
      const msg = `Error: ${e.message || e}`;
      setLog(msg);
    }
    await loadExtensions();
    renderSegments();
    renderCapabilities();
  }

  async function togglePack(name, enable) {
    try {
      const res = await apiPost('/api/toggle', { kind: 'pack', name, enable });
      if (!res.ok) {
        const msg = `${res.error || 'Toggle failed'}\n${res.stderr || ''}`.trim();
        setLog(msg);
      } else {
        setLog(`Pack ${name} ${enable ? 'enabled' : 'disabled'}.`);
      }
    } catch (e) {
      const msg = `Error: ${e.message || e}`;
      setLog(msg);
    }
    await loadPacks();
    renderSegments();
    renderCapabilities();
  }

  async function toggleCapability(id, enable) {
    try {
      const res = await apiPost('/api/capabilities/toggle', { id, enable });
      if (!res.ok) {
        setLog(res.error || 'Capability toggle failed.');
      } else {
        setLog(`Capability ${id} ${enable ? 'enabled' : 'disabled'}.`);
      }
    } catch (e) {
      setLog(`Error: ${e.message || e}`);
    }
    await Promise.all([loadPacks(), loadExtensions(), loadCapabilities()]);
    renderSegments();
  }

  async function runCapabilityChecks() {
    setCapCheckStatus(null, 'running...');
    try {
      const allow = !!(document.getElementById('capAllowToolRuns') || {}).checked;
      const res = await apiPost('/api/capabilities/check', { allow_tool_runs: allow });
      if (res.ok) {
        renderCapCheckResults(res.results || []);
        setCapCheckStatus(true, 'done');
        const lines = (res.results || []).map(r => {
          const detail = r.status ? `(${r.status})` : (r.error || '');
          return `${r.name}: ${r.ok ? 'ok' : 'down'} ${detail}`.trim();
        });
        setLog(lines.length ? `Capability checks:\n${lines.join('\n')}` : 'Capability checks complete.');
      } else {
        setCapCheckStatus(false, 'failed');
        showBanner(`Validation failed: ${res.error || 'unknown error'}`, 'error');
        setLog(`Validation failed: ${res.error || 'unknown error'}`);
      }
    } catch (e) {
      setCapCheckStatus(false, 'failed');
      showBanner(`Validation failed: ${e.message || e}`, 'error');
      setLog(`Validation failed: ${e.message || e}`);
    }
  }

  async function applySegment(id, enable) {
    const seg = SEGMENTS.find(s => s.id === id);
    if (!seg) return;
    try {
      for (const pack of (seg.packs || [])) {
        await apiPost('/api/toggle', { kind: 'pack', name: pack, enable });
      }
      for (const ext of (seg.extensions || [])) {
        await apiPost('/api/toggle', { kind: 'extension', name: ext, enable });
      }
    } finally {
      await Promise.all([loadPacks(), loadExtensions()]);
      renderSegments();
      renderCapabilities();
      setLog(`Segment ${seg.title || seg.id} ${enable ? 'enabled' : 'disabled'}.`);
    }
  }

  async function checkHealth() {
    const nodes = document.querySelectorAll('[data-health]');
    await Promise.all(Array.from(nodes).map(async node => {
      const url = node.getAttribute('data-health');
      if (!url) return;
      try {
        const res = await fetch(url, { method: 'GET' });
        node.textContent = res.ok ? 'ok' : 'down';
        node.className = res.ok ? 'pill ok' : 'pill bad';
      } catch (e) {
        node.textContent = 'down';
        node.className = 'pill bad';
      }
    }));
  }

  async function runCmd(cmd) {
    setLog(`Running: ${cmd}...`, { open: false });
    try {
      const res = await fetch(`/api/run?cmd=${encodeURIComponent(cmd)}`, {
        headers: { 'X-Beast-Token': state.token }
      });
      if (res.status === 401) {
        showBanner('Unauthorized. Paste the dashboard token and click Save.', 'error');
        setLog('Unauthorized. Set the dashboard token.');
        return;
      }
      const data = await res.json();
      setLog(`${data.cmd ? data.cmd.join(' ') : cmd}\n\n${data.stdout || ''}\n${data.stderr || ''}`.trim());
      if (!data.ok) {
        showBanner(`Command failed: ${cmd}`, 'error');
      }
    } catch (e) {
      setLog(`Error: ${e}`);
      showBanner(`Command failed: ${e}`, 'error');
    }
  }

  // LLM Model Management
  state.models = [];
  state.modelRegistry = [];
  state.ollamaRunning = false;
  state.availableModels = [];
  state.activeDownloads = {};

  async function refreshModels() {
    try {
      const data = await apiGet('/api/models?force=1');
      if (data.ok) {
        state.models = data.models || [];
        state.ollamaRunning = data.ollama_running;
        renderModels();
        updateOllamaStatus();
      } else if (data.error) {
        showBanner(`Model scan failed: ${data.error}`, 'error');
      }
    } catch (e) {
      console.error('Failed to load models:', e);
      showBanner('Model scan failed. Check dashboard token or Ollama.', 'error');
    }
    await loadModelRegistry();
    await loadStorageInfo();
  }

  async function loadStorageInfo() {
    try {
      const data = await apiGet('/api/models/storage');
      if (data.ok) {
        const el = document.getElementById('storageInfo');
        const s = data.storage;
        const parts = [];
        if (s.internal && s.internal.free_human) {
          parts.push(`Internal: ${s.internal.free_human} free`);
        }
        if (s.external && s.external.free_human && s.external.path !== s.internal?.path) {
          parts.push(`External: ${s.external.free_human} free`);
        }
        el.textContent = parts.length ? `Storage: ${parts.join(' | ')}` : '';
      } else if (data.error) {
        showBanner(`Storage info failed: ${data.error}`, 'error', 3000);
      }
    } catch (e) {}
  }

  function updateOllamaStatus() {
    const el = document.getElementById('ollamaStatus');
    if (state.ollamaRunning) {
      el.textContent = 'Ollama: online';
      el.className = 'pill ok';
    } else {
      el.textContent = 'Ollama: offline';
      el.className = 'pill bad';
    }
  }

  function renderModels() {
    const el = document.getElementById('modelList');
    if (!state.models.length) {
      el.innerHTML = '<div class="muted">No models found. Drop GGUF/safetensors files in the models directory or pull from Ollama.</div>';
      return;
    }
    const registryByName = {};
    (state.modelRegistry || []).forEach(item => {
      registryByName[item.name] = item;
    });
    el.innerHTML = state.models.map(m => {
      const isOllama = m.location === 'ollama';
      const icon = isOllama ? 'ðŸ¦™' : 'ðŸ“„';
      const locLabel = m.location.charAt(0).toUpperCase() + m.location.slice(1);
      const quantLabel = m.quantization ? ` (${m.quantization})` : '';
      const registry = registryByName[m.name];
      const registryLabel = registry ? `v${registry.current_version || 'n/a'}` : 'unregistered';
      const registerBtn = registry
        ? `<button class="btn ghost" onclick="rollbackModelPrompt('${m.name.replace(/'/g, "\\'")}')">Rollback</button>`
        : `<button class="btn ghost" onclick="registerModel('${m.name.replace(/'/g, "\\'")}', '${m.path.replace(/'/g, "\\'")}')">Register</button>`;
      return `
        <div class="tool">
          <div class="tool-header">
            <div class="tool-title">${icon} ${m.name}${quantLabel}</div>
            <div class="spacer"></div>
            <span class="pill">${m.size_human}</span>
            <span class="pill">${locLabel}</span>
            <span class="pill">${registryLabel}</span>
            ${registerBtn}
            <button class="btn ghost" onclick="deleteModel('${m.path.replace(/'/g, "\\'")}')">ðŸ—‘</button>
          </div>
          <div class="tool-desc">${m.model_type} | ${m.path}</div>
        </div>
      `;
    }).join('');
  }

  async function loadModelRegistry() {
    try {
      const data = await apiGet('/api/models/registry');
      if (data.ok) {
        state.modelRegistry = data.items || [];
        renderModelRegistry();
      }
    } catch (e) {}
  }

  function renderModelRegistry() {
    const el = document.getElementById('modelRegistryList');
    if (!el) return;
    if (!state.modelRegistry.length) {
      el.innerHTML = '<div class="muted">No registry entries yet.</div>';
      return;
    }
    el.innerHTML = state.modelRegistry.map(item => {
      const label = item.current_version ? `v${item.current_version}` : 'n/a';
      return `
        <div class="tool">
          <div class="tool-header">
            <div class="tool-title">ðŸ“˜ ${item.name}</div>
            <div class="spacer"></div>
            <span class="pill">${label}</span>
            <button class="btn ghost" onclick="rollbackModelPrompt('${item.name.replace(/'/g, "\\'")}')">Rollback</button>
            <button class="btn ghost" onclick="showModelVersions('${item.name.replace(/'/g, "\\'")}')">Versions</button>
          </div>
          <div class="tool-desc">${item.kind || 'unknown'} | ${item.path || 'n/a'}</div>
        </div>
      `;
    }).join('');
  }

  async function registerModel(name, path) {
    const version = prompt('Register version label (e.g., v1):', 'v1');
    if (!version) return;
    const model = (state.models || []).find(m => m.name === name) || {};
    const payload = {
      name,
      version,
      kind: model.model_type || '',
      path,
      checksum: model.sha256 || '',
      source_url: model.source_url || '',
    };
    const res = await apiPost('/api/models/registry/register', payload);
    if (res.ok) {
      setLog(`Registered ${name} at ${version}.`);
      await loadModelRegistry();
      renderModels();
    } else {
      setLog(res.error || 'Registry update failed.');
    }
  }

  async function rollbackModelPrompt(name) {
    const version = prompt(`Rollback ${name} to version:`);
    if (!version) return;
    const res = await apiPost('/api/models/registry/rollback', { name, version });
    if (res.ok) {
      setLog(`Rolled back ${name} to ${version}.`);
      await loadModelRegistry();
      renderModels();
    } else {
      setLog(res.error || 'Rollback failed.');
    }
  }

  async function showModelVersions(name) {
    const data = await apiGet(`/api/models/registry/versions?name=${encodeURIComponent(name)}`);
    if (!data.ok) {
      setLog(data.error || 'Failed to load versions.');
      return;
    }
    const lines = (data.items || []).map(v => `${v.version} | ${v.created_at}`);
    setLog(lines.length ? `Versions for ${name}:\n${lines.join('\n')}` : `No versions for ${name}.`);
  }

  async function deleteModel(path) {
    if (!confirm(`Delete model?\n${path}`)) return;
    try {
      const res = await apiPost('/api/models/delete', { path });
      if (res.ok) {
        await refreshModels();
      } else {
        setLog('Failed to delete: ' + (res.error || 'Unknown error'));
      }
    } catch (e) {
      setLog('Error: ' + e);
    }
  }

  async function showOllamaLibrary() {
    const panel = document.getElementById('ollamaLibrary');
    const list = document.getElementById('ollamaLibraryList');
    if (panel.style.display !== 'none') {
      panel.style.display = 'none';
      return;
    }
    document.getElementById('urlDownloadPanel').style.display = 'none';
    panel.style.display = 'block';
    try {
      const data = await apiGet('/api/models/available');
      if (data.ok) {
        state.availableModels = data.models || [];
        list.innerHTML = state.availableModels.map(m => 
          `<button class="btn" onclick="pullOllamaModel('${m.name}')" title="${m.desc} (${m.size})">${m.name}</button>`
        ).join('');
      }
    } catch (e) {
      list.innerHTML = '<div class="muted">Failed to load models</div>';
    }
  }

  async function pullOllamaModel(name) {
    if (!state.ollamaRunning) {
      setLog('Ollama is not running. Start it first.');
      return;
    }
    document.getElementById('ollamaLibrary').style.display = 'none';
    showDownloadProgress(name, 0);
    try {
      const res = await apiPost('/api/models/pull', { model: name });
      if (res.ok) {
        hideDownloadProgress();
        await refreshModels();
      } else {
        hideDownloadProgress();
        setLog('Failed to pull: ' + (res.error || 'Unknown error'));
      }
    } catch (e) {
      hideDownloadProgress();
      setLog('Error: ' + e);
    }
  }

  function showUrlDownload() {
    const panel = document.getElementById('urlDownloadPanel');
    if (panel.style.display !== 'none') {
      panel.style.display = 'none';
      return;
    }
    document.getElementById('ollamaLibrary').style.display = 'none';
    panel.style.display = 'block';
    
    document.getElementById('modelDestination').onchange = function() {
      document.getElementById('customPath').style.display = this.value === 'custom' ? 'block' : 'none';
    };
  }

  async function downloadFromUrl() {
    const url = document.getElementById('modelUrl').value.trim();
    if (!url) {
      setLog('Please enter a URL');
      return;
    }
    const destination = document.getElementById('modelDestination').value;
    const customPath = document.getElementById('customPath').value.trim();
    
    if (destination === 'custom' && !customPath) {
      setLog('Please enter a custom path');
      return;
    }

    document.getElementById('urlDownloadPanel').style.display = 'none';
    const filename = url.split('/').pop().split('?')[0] || 'model.gguf';
    showDownloadProgress(filename, 0);

    try {
      const res = await apiPost('/api/models/download', { 
        url, 
        destination,
        custom_path: customPath || undefined
      });
      if (res.ok) {
        // Poll for download progress
        pollDownloadStatus(res.download_id);
      } else {
        hideDownloadProgress();
        setLog('Failed to start download: ' + (res.error || 'Unknown error'));
      }
    } catch (e) {
      hideDownloadProgress();
      setLog('Error: ' + e);
    }
  }

  async function pollDownloadStatus(downloadId) {
    const poll = async () => {
      try {
        const data = await apiGet(`/api/models/downloads?id=${downloadId}`);
        if (data.ok) {
          const dl = data.downloads;
          if (dl.status === 'complete') {
            hideDownloadProgress();
            await refreshModels();
            return;
          } else if (dl.status === 'error') {
            hideDownloadProgress();
            setLog('Download failed: ' + (dl.error || 'Unknown error'));
            return;
          } else {
            updateDownloadProgress(dl.progress || 0);
            setTimeout(poll, 1000);
          }
        }
      } catch (e) {
        hideDownloadProgress();
      }
    };
    poll();
  }

  function showDownloadProgress(name, percent) {
    document.getElementById('downloadProgress').style.display = 'block';
    document.getElementById('downloadName').textContent = `Downloading: ${name}`;
    updateDownloadProgress(percent);
  }

  function updateDownloadProgress(percent) {
    document.getElementById('downloadPercent').textContent = `${Math.round(percent)}%`;
    document.getElementById('downloadBar').style.width = `${percent}%`;
  }

  function hideDownloadProgress() {
    document.getElementById('downloadProgress').style.display = 'none';
  }

  setupDockerLogControls();
  refreshAll();
  // Auto-refresh models every 30 seconds to detect dropped files
  setInterval(refreshModels, 30000);
</script>
</body>
</html>
