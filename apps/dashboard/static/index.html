<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>AI Beast Control Room</title>
  <style>
    :root {
      --bg-1: #0f1b2b;
      --bg-2: #1b2b3a;
      --card: #101826;
      --card-2: #121f30;
      --ink: #e7eef8;
      --muted: #94a3b8;
      --accent: #f6b93b;
      --accent-2: #00d2d3;
      --danger: #ff6b6b;
      --ok: #2dd4bf;
      --border: rgba(255,255,255,0.08);
      --shadow: 0 18px 50px rgba(8,12,20,0.45);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Avenir Next", "Segoe UI", sans-serif;
      color: var(--ink);
      background: radial-gradient(1200px 800px at 10% -20%, #243b55 0%, transparent 60%),
                  radial-gradient(800px 600px at 90% 0%, #1f4037 0%, transparent 55%),
                  linear-gradient(135deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    header {
      padding: 28px 28px 12px;
      display: grid;
      gap: 10px;
    }

    h1 {
      margin: 0;
      font-size: clamp(28px, 4vw, 44px);
      letter-spacing: -0.02em;
    }

    .sub {
      color: var(--muted);
      max-width: 720px;
      line-height: 1.5;
    }

    .wrap {
      padding: 0 24px 40px;
      display: grid;
      gap: 18px;
    }

    .grid {
      display: grid;
      gap: 18px;
    }

    .grid.two { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .grid.three { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }

    .card {
      background: linear-gradient(160deg, var(--card), var(--card-2));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
      box-shadow: var(--shadow);
      position: relative;
      overflow: hidden;
      animation: rise 0.6s ease both;
      animation-delay: var(--delay, 0ms);
    }

    .card::after {
      content: "";
      position: absolute;
      top: -80px;
      right: -80px;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
      pointer-events: none;
    }

    .card h3 {
      margin: 0 0 10px;
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--accent);
    }

    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .spacer { flex: 1 1 auto; }

    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      font-size: 12px;
      color: var(--muted);
    }

    .btn {
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--ink);
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 600;
    }

    .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.2); }
    .btn.primary { background: var(--accent); color: #1b1b1b; }
    .btn.ghost { background: transparent; }

    .token-input {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.2);
      color: var(--ink);
      min-width: 260px;
      flex: 1 1 260px;
    }

    .muted { color: var(--muted); font-size: 13px; }
    .stat { font-size: 22px; font-weight: 700; }
    .ok { color: var(--ok); }
    .bad { color: var(--danger); }

    .tool-list { display: grid; gap: 12px; }
    .tool {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      background: rgba(7,12,20,0.5);
      display: grid;
      gap: 8px;
    }

    .tool-header { display: flex; gap: 10px; align-items: center; }
    .tool-title { font-weight: 700; font-size: 16px; }
    .tool-desc { color: var(--muted); font-size: 13px; line-height: 1.4; }
    .tool-links { display: flex; flex-wrap: wrap; gap: 8px; }

    .link {
      color: var(--accent-2);
      text-decoration: none;
      font-size: 13px;
    }

    .toggle {
      position: relative;
      width: 46px;
      height: 26px;
    }

    .toggle input { opacity: 0; width: 0; height: 0; }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255,255,255,0.2);
      border-radius: 999px;
      transition: 0.2s;
    }

    .slider::before {
      content: "";
      position: absolute;
      height: 20px;
      width: 20px;
      left: 3px;
      top: 3px;
      background: #0b1220;
      border-radius: 50%;
      transition: 0.2s;
    }

    .toggle input:checked + .slider { background: var(--accent-2); }
    .toggle input:checked + .slider::before { transform: translateX(20px); }

    .terminal {
      background: #070b12;
      border-radius: 14px;
      padding: 14px;
      font-family: "JetBrains Mono", "SFMono-Regular", Menlo, monospace;
      font-size: 12px;
      color: #cbd5f5;
      max-height: 260px;
      overflow: auto;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(3, 6, 12, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .modal-card {
      background: linear-gradient(160deg, var(--card), var(--card-2));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
      width: min(880px, 92vw);
      max-height: 80vh;
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    @keyframes rise {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (prefers-reduced-motion: reduce) {
      .card { animation: none; }
      .btn:hover { transform: none; }
    }
  </style>
</head>
<body>
  <header>
    <h1>AI Beast Control Room</h1>
    <div class="sub">One panel for the entire stack. Toggle packs and extensions, jump to portals and APIs, and monitor resource headroom.</div>
  </header>

  <div class="wrap">
    <section class="card" style="--delay: 50ms;">
      <div class="row">
        <div>
          <div class="muted">Dashboard Token</div>
          <input id="token" class="token-input" placeholder="Paste dashboard token" />
        </div>
        <button class="btn" onclick="saveToken()">Save</button>
        <button class="btn ghost" onclick="refreshAll()">Refresh</button>
        <div class="spacer"></div>
        <div id="health" class="pill">checking...</div>
      </div>
    </section>

    <section class="grid two">
      <div class="card" style="--delay: 120ms;">
        <h3>System</h3>
        <div id="systemMetrics" class="tool-list"></div>
      </div>
      <div class="card" style="--delay: 180ms;">
        <h3>Actions</h3>
        <div class="row">
          <button class="btn" onclick="runCmd('preflight')">Preflight</button>
          <button class="btn" onclick="runCmd('status')">Status</button>
          <button class="btn" onclick="runCmd('doctor')">Doctor</button>
          <button class="btn" onclick="runCmd('compose_gen')">Compose Gen</button>
          <button class="btn" onclick="runCmd('up')">Up</button>
          <button class="btn" onclick="runCmd('down')">Down</button>
          <button class="btn" onclick="runCmd('speech_up')">Speech Up</button>
          <button class="btn" onclick="runCmd('speech_down')">Speech Down</button>
        </div>
        <div class="muted" style="margin-top:10px;">All commands run via <code>bin/beast</code> on the host.</div>
      </div>
    </section>

    <section class="card" style="--delay: 190ms;">
      <h3>Storage Paths</h3>
      <div class="muted" style="margin-bottom: 8px;">Update GUTS/HEAVY storage locations (re-runs init and creates dirs).</div>
      <div class="row" style="gap: 10px; margin-bottom: 10px;">
        <input id="gutsDir" class="token-input" placeholder="GUTS_DIR (internal, apps/venv)" />
        <input id="heavyDir" class="token-input" placeholder="HEAVY_DIR (external, models/data)" />
      </div>
      <div class="row">
        <button class="btn primary" onclick="savePaths()">Save Paths</button>
        <span id="pathsStatus" class="pill">idle</span>
      </div>
    </section>

    <section class="card" style="--delay: 210ms;">
      <h3>Capabilities</h3>
      <div id="capabilityList" class="tool-list"></div>
    </section>

    <section class="card" style="--delay: 225ms;">
      <h3>Tools</h3>
      <div class="tool" style="margin-bottom: 12px;">
        <div class="tool-header">
          <div class="tool-title">Tool Catalog</div>
          <div class="spacer"></div>
          <span class="pill">missing only</span>
        </div>
        <div class="tool-desc">Select uninstalled tools and add/install them in bulk.</div>
        <select id="toolCatalogSelect" class="token-input" multiple style="min-height: 140px;"></select>
        <div class="row" style="margin-top: 8px; gap: 8px; flex-wrap: wrap;">
          <button class="btn" onclick="addSelectedTools()">Add Selected</button>
          <button class="btn primary" onclick="installSelectedTools()">Add + Install</button>
        </div>
      </div>
      <div class="tool" style="margin-bottom: 12px;">
        <div class="tool-header">
          <div class="tool-title">Custom Download URL</div>
          <div class="spacer"></div>
          <span class="pill">tar.gz</span>
        </div>
        <div class="tool-desc">Register a tool archive by URL, then install it.</div>
        <div class="row" style="gap: 8px; flex-wrap: wrap;">
          <input id="customToolName" class="token-input" placeholder="tool name (no spaces)" />
          <input id="customToolUrl" class="token-input" placeholder="https://.../tool.tar.gz" />
          <input id="customToolEntrypoint" class="token-input" placeholder="entrypoint (optional)" />
          <input id="customToolTest" class="token-input" placeholder="test command (optional)" />
        </div>
        <div class="row" style="margin-top: 8px; gap: 8px; flex-wrap: wrap;">
          <button class="btn" onclick="registerCustomTool()">Add Tool</button>
          <button class="btn primary" onclick="registerAndInstallCustomTool()">Add + Install</button>
        </div>
      </div>
      <div id="toolsList" class="tool-list"></div>
    </section>

    <section class="grid two">
      <div class="card" style="--delay: 235ms;">
        <h3>Features</h3>
        <div class="row" style="margin-bottom: 8px;">
          <button class="btn" onclick="applyFeatureChanges()">Apply Changes</button>
          <span class="muted">Runs compose gen + up</span>
        </div>
        <div id="featureList" class="tool-list"></div>
      </div>
      <div class="card" style="--delay: 235ms;">
        <h3>Runtime Settings</h3>
        <div class="tool-desc">Profile + runtime knobs used by startup and compose generation.</div>
        <div id="settingsList" class="tool-list"></div>
        <div class="row" style="margin-top: 8px;">
          <button class="btn" onclick="applyFeatureChanges()">Apply Changes</button>
          <span class="muted">Regenerate compose + up</span>
        </div>
      </div>
      <div class="card" style="--delay: 240ms;">
        <h3>Packs</h3>
        <div id="packList" class="tool-list"></div>
      </div>
      <div class="card" style="--delay: 300ms;">
        <h3>Extensions</h3>
        <div id="extensionList" class="tool-list"></div>
      </div>
    </section>

    <section class="card" style="--delay: 360ms;">
      <h3>Services & Ports</h3>
      <div id="serviceList" class="tool-list"></div>
    </section>

    <section class="card" style="--delay: 420ms;">
      <h3>Command Output</h3>
      <div id="log" class="terminal">Ready.</div>
    </section>
  </div>

  <div id="modal" class="modal" style="display:none;">
    <div class="modal-card">
      <div class="row">
        <div class="tool-title">Console Output</div>
        <div class="spacer"></div>
        <button class="btn" onclick="askLlmFromModal()">Ask LLM</button>
        <button class="btn ghost" onclick="closeModal()">Close</button>
      </div>
      <div id="modalBody" class="terminal" style="margin-top: 10px; max-height: 60vh;">...</div>
    </div>
  </div>

  <div id="capModal" class="modal" style="display:none;">
    <div class="modal-card">
      <div class="row">
        <div class="tool-title">Capability Details</div>
        <div class="spacer"></div>
        <button class="btn ghost" onclick="closeCapModal()">Close</button>
      </div>
      <div id="capModalBody" class="terminal" style="margin-top: 10px; max-height: 45vh;">...</div>
      <div style="margin-top: 12px;">
        <div class="tool-title" style="font-size: 12px; letter-spacing: 0.04em; text-transform: uppercase;">CLI Template</div>
        <textarea id="capTemplate" class="input" style="min-height: 120px; margin-top: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;"></textarea>
        <div class="row" style="margin-top: 10px;">
          <button class="btn" onclick="saveCapabilityTemplate()">Save Template</button>
          <button class="btn ghost" onclick="askCapabilityTemplate()">Ask LLM (template)</button>
        </div>
      </div>
    </div>
  </div>

  <div id="toolModal" class="modal" style="display:none;">
    <div class="modal-card">
      <div class="row">
        <div class="tool-title">Tool Configuration</div>
        <div class="spacer"></div>
        <button class="btn ghost" onclick="closeToolModal()">Close</button>
      </div>
      <div class="tool-desc" id="toolModalTitle" style="margin-top: 6px;"></div>
      <div class="row" style="gap: 8px; flex-wrap: wrap; margin-top: 10px;">
        <input id="toolEntry" class="token-input" placeholder="entrypoint" />
        <input id="toolArgs" class="token-input" placeholder="args" />
        <input id="toolTestCmd" class="token-input" placeholder="test command" />
        <input id="toolTestUrl" class="token-input" placeholder="test URL" />
        <input id="toolDownloadUrl" class="token-input" placeholder="download URL (tar.gz)" />
        <input id="toolInstallCmd" class="token-input" placeholder="install command" />
      </div>
      <div style="margin-top: 10px;">
        <div class="tool-title" style="font-size: 12px; letter-spacing: 0.04em; text-transform: uppercase;">Env (JSON)</div>
        <textarea id="toolEnv" class="input" style="min-height: 90px; margin-top: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;"></textarea>
      </div>
      <div style="margin-top: 10px;">
        <div class="tool-title" style="font-size: 12px; letter-spacing: 0.04em; text-transform: uppercase;">Config Hint</div>
        <textarea id="toolConfigHint" class="input" style="min-height: 90px; margin-top: 6px;"></textarea>
      </div>
      <div style="margin-top: 10px;">
        <div class="tool-title" style="font-size: 12px; letter-spacing: 0.04em; text-transform: uppercase;">Workflow</div>
        <textarea id="toolWorkflow" class="input" style="min-height: 90px; margin-top: 6px;"></textarea>
      </div>
      <div class="row" style="margin-top: 10px;">
        <button class="btn" onclick="saveToolConfig()">Save Tool</button>
      </div>
    </div>
  </div>

<script>
  const state = {
    token: localStorage.getItem('beast_token') || '',
    config: {},
    packs: [],
    extensions: [],
    capabilities: [],
    services: [],
    tools: [],
    catalog: [],
    features: [],
    settings: [],
    metrics: {},
    currentCapabilityId: null,
    currentToolName: null,
    applyInFlight: false,
  };

  const EXT_INFO = {
    dify: {
      title: 'Dify',
      description: 'Low-code agent builder stack with API + web UI.',
      ports: ['PORT_DIFY'],
      portal: cfg => url(cfg, 'PORT_DIFY'),
      api: 'internal: dify-api:5001',
    },
    flowise: {
      title: 'Flowise',
      description: 'Flow-based LLM orchestration UI.',
      ports: ['PORT_FLOWISE'],
      portal: cfg => url(cfg, 'PORT_FLOWISE'),
      api: cfg => url(cfg, 'PORT_FLOWISE'),
    },
    langflow: {
      title: 'Langflow',
      description: 'Visual builder for LLM chains and data flows.',
      ports: ['PORT_LANGFLOW'],
      portal: cfg => url(cfg, 'PORT_LANGFLOW'),
      api: cfg => url(cfg, 'PORT_LANGFLOW'),
    },
    searxng: {
      title: 'SearxNG',
      description: 'Meta-search engine for OSINT.',
      ports: ['PORT_SEARXNG'],
      portal: cfg => url(cfg, 'PORT_SEARXNG'),
      api: cfg => url(cfg, 'PORT_SEARXNG'),
    },
    jupyter: {
      title: 'JupyterLab',
      description: 'Notebook-based code runner and analysis.',
      ports: ['PORT_JUPYTER'],
      portal: cfg => url(cfg, 'PORT_JUPYTER', 'lab'),
      api: cfg => url(cfg, 'PORT_JUPYTER', 'api'),
    },
    apache_tika: {
      title: 'Apache Tika',
      description: 'Document parsing and normalization.',
      ports: ['PORT_TIKA'],
      portal: cfg => url(cfg, 'PORT_TIKA'),
      api: cfg => url(cfg, 'PORT_TIKA'),
    },
    unstructured_api: {
      title: 'Unstructured API',
      description: 'Document chunking and preprocessing.',
      ports: ['PORT_UNSTRUCTURED'],
      portal: cfg => url(cfg, 'PORT_UNSTRUCTURED'),
      api: cfg => url(cfg, 'PORT_UNSTRUCTURED'),
    },
    otel_collector: {
      title: 'OTel Collector',
      description: 'Telemetry collection pipeline.',
      ports: ['PORT_OTEL_GRPC', 'PORT_OTEL_HTTP'],
      portal: null,
      api: cfg => `http://${bind(cfg)}:${port(cfg, 'PORT_OTEL_HTTP', 4318)}`,
    },
    minio: {
      title: 'MinIO',
      description: 'S3-compatible object storage.',
      ports: ['PORT_MINIO', 'PORT_MINIO_CONSOLE'],
      portal: cfg => `http://${bind(cfg)}:${port(cfg, 'PORT_MINIO_CONSOLE', 9002)}`,
      api: cfg => `http://${bind(cfg)}:${port(cfg, 'PORT_MINIO', 9001)}`,
    },
    comfyui_manager: {
      title: 'ComfyUI Manager',
      description: 'ComfyUI custom node manager (native add-on).',
      ports: [],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: null,
    },
    comfyui_video: {
      title: 'ComfyUI Video',
      description: 'Video pipeline nodes for ComfyUI.',
      ports: [],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: null,
    },
    example_service: { title: 'Example Service', description: 'Example extension service.', ports: [], portal: null, api: null },
    example_segment: { title: 'Example Segment', description: 'Example segment extension.', ports: [], portal: null, api: null },
  };

  const NATIVE_SERVICES = [
    { name: 'Ollama API', port: 'PORT_OLLAMA', path: '/api/version', api: '/api/version', desc: 'Local model API.', logApp: '' },
    { name: 'ComfyUI', port: 'PORT_COMFYUI', path: '', api: '', desc: 'Image pipeline UI.', logApp: 'comfyui' },
    { name: 'Dashboard', port: 'PORT_DASHBOARD', path: '', api: '', desc: 'Admin control panel.', logApp: 'dashboard' },
    { name: 'Speech API', port: 'PORT_SPEECH_API', path: '/docs', api: '/docs', desc: 'Local speech (STT/TTS) API.', logApp: '' },
  ];

  const CAPABILITIES = [
    {
      id: 'text2image',
      title: 'Text → Image',
      description: 'Generate images with ComfyUI workflows.',
      packs: ['media_synth'],
      extensions: [],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: cfg => url(cfg, 'PORT_COMFYUI', 'object_info'),
      health: cfg => url(cfg, 'PORT_COMFYUI', ''),
      ports: ['PORT_COMFYUI'],
      notes: 'Requires ComfyUI models; install separately.',
    },
    {
      id: 'text2video',
      title: 'Text → Video',
      description: 'Video generation via ComfyUI + VideoHelperSuite nodes.',
      packs: ['media_synth'],
      extensions: ['comfyui_video'],
      portal: cfg => url(cfg, 'PORT_COMFYUI'),
      api: cfg => url(cfg, 'PORT_COMFYUI', 'object_info'),
      health: cfg => url(cfg, 'PORT_COMFYUI', ''),
      ports: ['PORT_COMFYUI'],
      notes: 'Enable ComfyUI Video extension and install video workflows.',
    },
    {
      id: 'text2audio',
      title: 'Text → Audio',
      description: 'Speech synthesis via the local Speech API.',
      packs: ['speech_stack'],
      extensions: [],
      portal: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      api: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      health: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      ports: ['PORT_SPEECH_API'],
      notes: 'Start the service with the Speech Up action.',
    },
    {
      id: 'text2music',
      title: 'Text → Music',
      description: 'Use speech + audio tooling for music prompts (models required).',
      packs: ['media_synth', 'speech_stack'],
      extensions: [],
      portal: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      api: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      health: cfg => url(cfg, 'PORT_SPEECH_API', 'docs'),
      ports: ['PORT_SPEECH_API'],
      notes: 'Pair with external music models or ComfyUI audio workflows.',
    },
  ];

  const PACK_LINKS = {
    media_synth: cfg => [ { label: 'ComfyUI', url: url(cfg, 'PORT_COMFYUI') } ],
    speech_stack: cfg => [ { label: 'Speech API', url: url(cfg, 'PORT_SPEECH_API', 'docs') } ],
  };

  document.getElementById('token').value = state.token;

  function bind(cfg) {
    return cfg.AI_BEAST_BIND_ADDR || '127.0.0.1';
  }

  function port(cfg, key, fallback) {
    return cfg[key] || fallback || '';
  }

  function url(cfg, key, path='') {
    const p = port(cfg, key, '');
    if (!p) return '';
    const suffix = path ? `/${path.replace(/^\//, '')}` : '';
    return `http://${bind(cfg)}:${p}${suffix}`;
  }

  function setLog(message, openModalFlag = true) {
    const log = document.getElementById('log');
    if (log) log.textContent = message;
    const modal = document.getElementById('modal');
    const modalBody = document.getElementById('modalBody');
    if (modalBody) modalBody.textContent = message;
    if (modal && openModalFlag) {
      modal.style.display = 'flex';
    }
  }

  function closeModal() {
    const modal = document.getElementById('modal');
    if (modal) modal.style.display = 'none';
  }

  async function askLlmFromModal() {
    const modalBody = document.getElementById('modalBody');
    const prompt = (modalBody && modalBody.textContent || '').trim();
    if (!prompt) {
      setLog('No output to send to the LLM.');
      return;
    }
    try {
      const res = await apiPost('/api/llm/analyze', { prompt });
      if (res.ok) {
        setLog(res.response || 'LLM returned no content.');
      } else {
        setLog(res.error || 'LLM request failed.');
      }
    } catch (e) {
      setLog(`LLM error: ${e}`);
    }
  }

  function closeCapModal() {
    const modal = document.getElementById('capModal');
    if (modal) modal.style.display = 'none';
  }

  function openCapabilityDetails(id) {
    const caps = state.capabilities.length ? state.capabilities : CAPABILITIES;
    const cap = caps.find(c => c.id === id);
    if (!cap) return;
    state.currentCapabilityId = id;
    const lines = [];
    lines.push(`${cap.title || cap.id}`);
    if (cap.description) lines.push(`\n${cap.description}`);
    if (cap.notes) lines.push(`\nNotes: ${cap.notes}`);
    if (cap.webui && cap.webui.category) lines.push(`WebUI: ${cap.webui.category}`);
    if (cap.ollama && cap.ollama.model) lines.push(`Ollama Model: ${cap.ollama.model}`);
    if (cap.ollama && cap.ollama.embedding_model) lines.push(`Embedding Model: ${cap.ollama.embedding_model}`);
    if (cap.packs && cap.packs.length) lines.push(`Packs: ${cap.packs.join(', ')}`);
    if (cap.extensions && cap.extensions.length) lines.push(`Extensions: ${cap.extensions.join(', ')}`);
    if (cap.ports && cap.ports.length) lines.push(`Ports: ${cap.ports.map(p => `${p}=${port(state.config, p, '-')}`).join(' | ')}`);
    if (cap.portal) lines.push(`Portal: ${cap.portal.port ? url(state.config, cap.portal.port, cap.portal.path || '') : (cap.portal.url || '')}`);
    if (cap.api) lines.push(`API: ${cap.api.port ? url(state.config, cap.api.port, cap.api.path || '') : (cap.api.url || '')}`);
    if (cap.health) lines.push(`Health: ${cap.health.port ? url(state.config, cap.health.port, cap.health.path || '') : (cap.health.url || '')}`);
    if (cap.checks && cap.checks.length) {
      lines.push('\nChecks:');
      cap.checks.forEach((c, idx) => {
        const label = c.name || c.type || `check-${idx + 1}`;
        const detail = c.type === 'http'
          ? `${c.type} ${c.port || ''}/${c.path || ''}`.trim()
          : (c.type === 'tool' ? `tool ${c.tool || ''}` : c.type);
        lines.push(`- ${label}: ${detail}`);
      });
    }
    if (cap.actions && cap.actions.length) {
      lines.push('\nActions:');
      cap.actions.forEach((a, idx) => {
        const label = a.label || `action-${idx + 1}`;
        const detail = a.type === 'open_url'
          ? `open ${a.port || ''}/${a.path || ''}`.trim()
          : (a.type === 'beast_cmd' ? `beast ${a.cmd || ''}` : a.type);
        lines.push(`- ${label}: ${detail}`);
      });
    }
    lines.push('\nAsk: Use the "Ask LLM" button on this capability card for CLI guidance.');
    const modalBody = document.getElementById('capModalBody');
    if (modalBody) modalBody.textContent = lines.join('\n');
    const templateBox = document.getElementById('capTemplate');
    if (templateBox) templateBox.value = cap.cli_template || '';
    const modal = document.getElementById('capModal');
    if (modal) modal.style.display = 'flex';
  }

  async function saveCapabilityTemplate() {
    const capId = state.currentCapabilityId;
    if (!capId) {
      setLog('Missing capability id.');
      return;
    }
    const templateBox = document.getElementById('capTemplate');
    const template = templateBox ? templateBox.value : '';
    try {
      const res = await apiPost('/api/capabilities/template', { id: capId, template });
      if (res.ok) {
        const cap = (state.capabilities || []).find(c => c.id === capId);
        if (cap) cap.cli_template = res.cli_template || template;
        setLog(`Saved template for ${capId}.`);
      } else {
        setLog(res.error || 'Failed to save template.');
      }
    } catch (e) {
      setLog(`Template save error: ${e}`);
    }
  }

  async function askCapabilityTemplate() {
    const capId = state.currentCapabilityId;
    if (!capId) {
      setLog('Missing capability id.');
      return;
    }
    const templateBox = document.getElementById('capTemplate');
    const template = (templateBox ? templateBox.value : '').trim();
    if (!template) {
      setLog('No template provided for this capability.');
      return;
    }
    const prompt = `Fill in this CLI template for capability ${capId}. Provide exact commands and brief notes where to run them.\n\n${template}`;
    try {
      const res = await apiPost('/api/llm/analyze', { prompt });
      if (res.ok) {
        setLog(res.response || 'LLM returned no content.');
      } else {
        setLog(res.error || 'LLM request failed.');
      }
    } catch (e) {
      setLog(`LLM error: ${e}`);
    }
  }

  function saveToken() {
    state.token = document.getElementById('token').value.trim();
    localStorage.setItem('beast_token', state.token);
    refreshAll();
  }

  function setHealth(ok) {
    const el = document.getElementById('health');
    el.textContent = ok ? 'online' : 'offline';
    el.className = ok ? 'pill ok' : 'pill bad';
  }

  async function apiGet(path) {
    const res = await fetch(path, {
      headers: { 'X-Beast-Token': state.token }
    });
    return res.json();
  }

  async function apiPost(path, body) {
    const res = await fetch(path, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Beast-Token': state.token,
      },
      body: JSON.stringify(body)
    });
    return res.json();
  }

  function toolAvailable(name) {
    const tool = (state.tools || []).find(t => t.name === name);
    return tool ? tool.available : false;
  }

  function toolConfig(name) {
    return (state.tools || []).find(t => t.name === name);
  }

  async function loadServices() {
    const data = await apiGet('/api/services');
    if (data.ok) {
      state.services = data.items || [];
      renderServices();
    }
  }

  async function loadTools() {
    const data = await apiGet('/api/tools/list');
    if (data.ok) {
      state.tools = data.items || [];
      renderCapabilities();
      renderTools();
    }
  }

  async function loadToolCatalog() {
    const data = await apiGet('/api/tools/catalog');
    if (data.ok) {
      state.catalog = (data.items || []).filter(item => !item.available);
      renderToolCatalog();
    }
  }

  async function loadFeatures() {
    const data = await apiGet('/api/features');
    if (data.ok) {
      state.features = data.items || [];
      renderFeatures();
    }
  }

  async function loadSettings() {
    const data = await apiGet('/api/settings');
    if (data.ok) {
      state.settings = data.items || [];
      renderSettings();
    }
  }

  function renderSettings() {
    const el = document.getElementById('settingsList');
    if (!el) return;
    const items = (state.settings || []).map(setting => {
      const key = setting.key;
      const desc = setting.description || '';
      if (setting.type === 'bool') {
        const enabled = String(setting.value).trim() === '1' || String(setting.value).toLowerCase() === 'true';
        return `
          <div class="tool">
            <div class="tool-header">
              <div class="tool-title">${key}</div>
              <div class="spacer"></div>
              <label class="toggle">
                <input type="checkbox" ${enabled ? 'checked' : ''} onchange="setSetting('${key}', ${!enabled})">
                <span class="slider"></span>
              </label>
            </div>
            <div class="tool-desc">${desc}</div>
          </div>
        `;
      }
      if (setting.type === 'select') {
        const options = (setting.options || []).map(opt => `<option value="${opt}" ${opt === setting.value ? 'selected' : ''}>${opt}</option>`).join('');
        return `
          <div class="tool">
            <div class="tool-header">
              <div class="tool-title">${key}</div>
              <div class="spacer"></div>
            </div>
            <div class="tool-desc">${desc}</div>
            <div class="row" style="margin-top: 8px; gap: 8px; flex-wrap: wrap;">
              <select id="setting-${key}" class="token-input">${options}</select>
              <button class="btn ghost" onclick="saveSetting('${key}')">Save</button>
            </div>
          </div>
        `;
      }
      return `
        <div class="tool">
          <div class="tool-header">
            <div class="tool-title">${key}</div>
            <div class="spacer"></div>
          </div>
          <div class="tool-desc">${desc}</div>
          <div class="row" style="margin-top: 8px; gap: 8px; flex-wrap: wrap;">
            <input id="setting-${key}" class="token-input" value="${setting.value || ''}">
            <button class="btn ghost" onclick="saveSetting('${key}')">Save</button>
          </div>
        </div>
      `;
    });
    el.innerHTML = items.join('') || '<div class="muted">No settings found.</div>';
  }

  function renderFeatures() {
    const el = document.getElementById('featureList');
    if (!el) return;
    const items = (state.features || []).map(feature => {
      const enabled = feature.bool ? !!feature.enabled : null;
      const toggle = feature.bool ? `
        <label class="toggle">
          <input type="checkbox" ${enabled ? 'checked' : ''} onchange="setFeature('${feature.key}', ${!enabled})">
          <span class="slider"></span>
        </label>` : '';
      const valueInput = !feature.bool ? `
        <input id="feature-value-${feature.key}" class="token-input" value="${feature.value || ''}" placeholder="value">
        <button class="btn ghost" onclick="saveFeatureValue('${feature.key}')">Save</button>` : '';
      const badge = feature.has_override ? '<span class="pill">override</span>' : '';
      return `
        <div class="tool">
          <div class="tool-header">
            <div class="tool-title">${feature.key}</div>
            <div class="spacer"></div>
            ${badge}
            ${toggle}
          </div>
          <div class="tool-desc">${feature.value}</div>
          ${valueInput ? `<div class="row" style="margin-top: 8px; gap: 8px; flex-wrap: wrap;">${valueInput}</div>` : ''}
        </div>
      `;
    });
    el.innerHTML = items.join('') || '<div class="muted">No features found.</div>';
  }

  function renderToolCatalog() {
    const select = document.getElementById('toolCatalogSelect');
    if (!select) return;
    const options = (state.catalog || []).map(item => {
      const label = `${item.name}${item.description ? ` — ${item.description}` : ''}`;
      return `<option value="${item.name}">${label}</option>`;
    });
    select.innerHTML = options.join('') || '<option value="" disabled>No missing tools found.</option>';
  }

  async function loadCapabilities() {
    const data = await apiGet('/api/capabilities');
    if (data.ok) {
      state.capabilities = data.items || [];
      renderCapabilities();
    }
  }

  async function refreshAll() {
    try {
      const health = await fetch('/api/health');
      setHealth(health.ok);
    } catch (e) {
      setHealth(false);
    }
    await Promise.all([
      loadConfig(),
      loadPacks(),
      loadExtensions(),
      loadFeatures(),
      loadSettings(),
      loadServices(),
      loadTools(),
      loadCapabilities(),
      loadToolCatalog(),
      loadMetrics()
    ]);
    renderServices();
    renderCapabilities();
    await checkHealth();
  }

  async function loadConfig() {
    const data = await apiGet('/api/config');
    if (data.ok) {
      state.config = data.config || {};
      renderPathsForm();
      renderMetrics();
    }
  }

  async function loadPacks() {
    const data = await apiGet('/api/packs');
    if (data.ok) {
      state.packs = data.items || [];
      renderPacks();
    }
  }

  async function loadExtensions() {
    const data = await apiGet('/api/extensions');
    if (data.ok) {
      state.extensions = data.items || [];
      renderExtensions();
    }
  }

  async function loadMetrics() {
    const data = await apiGet('/api/metrics');
    if (data.ok) {
      state.metrics = data.metrics || {};
      renderMetrics();
    }
  }

  function renderMetrics() {
    const el = document.getElementById('systemMetrics');
    const disk = state.metrics.disk_usage || {};
    const mem = state.metrics.memory || {};
    const rows = [
      metricRow('Base Dir', state.config.BASE_DIR || 'unknown'),
      metricRow('Guts Dir', state.config.GUTS_DIR || 'n/a'),
      metricRow('Heavy Dir', state.config.HEAVY_DIR || 'n/a'),
      metricRow('Models Dir', state.config.MODELS_DIR || 'n/a'),
      metricRow('Data Dir', state.config.DATA_DIR || 'n/a'),
      metricRow('LLM Models', state.config.LLM_MODELS_DIR || 'n/a'),
      metricRow('Ollama Models', state.config.OLLAMA_MODELS || 'n/a'),
      metricRow('Disk Used', disk.total_gb ? `${disk.used_gb} / ${disk.total_gb} GB (${disk.percent_used}%)` : 'n/a'),
      metricRow('Disk Free', disk.free_gb ? `${disk.free_gb} GB` : 'n/a'),
      metricRow('Memory Used', mem.total_gb ? `${mem.used_gb} / ${mem.total_gb} GB (${mem.percent_used}%)` : 'n/a'),
      metricRow('Bind Addr', bind(state.config)),
    ];
    el.innerHTML = rows.join('');
  }

  function packEnabled(name) {
    const pack = state.packs.find(p => p.name === name);
    return !!(pack && pack.enabled);
  }

  function extensionEnabled(name) {
    const ext = state.extensions.find(e => e.name === name);
    return !!(ext && ext.enabled === 'true');
  }

  function capabilityEnabled(cap) {
    const packsOk = (cap.packs || []).every(packEnabled);
    const extsOk = (cap.extensions || []).every(extensionEnabled);
    return packsOk && extsOk;
  }

  function renderCapabilities() {
    const el = document.getElementById('capabilityList');
    if (!el) return;
    state.capabilityActions = {};
    const caps = state.capabilities.length ? state.capabilities : CAPABILITIES;
    el.innerHTML = caps.map(cap => {
      const enabled = capabilityEnabled(cap);
      const portal = typeof cap.portal === 'function' ? cap.portal(state.config) : cap.portal;
      const api = typeof cap.api === 'function' ? cap.api(state.config) : cap.api;
      const health = cap.health ? cap.health(state.config) : api;
      const links = [];
      if (portal) links.push({ label: 'Portal', url: portal });
      if (api) links.push({ label: 'API', url: api });
      if (cap.webui) {
        const webuiUrl = url(state.config, 'PORT_WEBUI', cap.webui.path || '');
        if (webuiUrl) links.push({ label: 'WebUI', url: webuiUrl });
      }
      const ports = (cap.ports || []).map(key => `${key}=${port(state.config, key, '-')}`);
      const actions = (cap.actions || []).slice();
      if (cap.ollama && cap.ollama.model) {
        const model = cap.ollama.model;
        if (!actions.some(a => a.type === 'ollama_pull' && a.model === model)) {
          actions.unshift({ label: `Pull ${model}`, type: 'ollama_pull', model });
        }
      }
      (cap.checks || []).forEach(check => {
        if (check.type === 'tool' && check.tool && !actions.some(a => a.type === 'tool_run' && a.tool === check.tool)) {
          actions.push({ label: `Run ${check.tool}`, type: 'tool_run', tool: check.tool, args: check.args || '' });
        }
      });
      (cap.packs || []).forEach(pack => {
        if (!packEnabled(pack)) {
          actions.push({ label: `Enable pack: ${pack}`, type: 'pack_enable', pack });
        }
      });
      (cap.extensions || []).forEach(ext => {
        if (!extensionEnabled(ext)) {
          const meta = (state.extensions || []).find(e => e.name === ext);
          if (meta && meta.has_installer === 'true') {
            actions.push({ label: `Install ext: ${ext}`, type: 'extension_install', extension: ext });
          } else {
            actions.push({ label: `Enable ext: ${ext}`, type: 'extension_enable', extension: ext });
          }
        }
      });
      actions.forEach(action => {
        if (action.type === 'tool_run' && action.tool && !toolAvailable(action.tool)) {
          actions.push({ label: `Fetch ${action.tool}`, type: 'tool_install', tool: action.tool });
        }
      });
      state.capabilityActions[cap.id] = actions;
      const actionsHtml = actions.map((act, idx) => {
        return `<button class="btn ghost" onclick="handleCapabilityAction('${cap.id}', ${idx})">${act.label}</button>`;
      }).join('') + `<button class="btn ghost" onclick="askCapability('${cap.id}')">Ask LLM</button>` + `<button class="btn ghost" onclick="openCapabilityDetails('${cap.id}')">Details</button>`;
      const integrationNotes = [];
      if (cap.webui && cap.webui.category) integrationNotes.push(`WebUI: ${cap.webui.category}`);
      if (cap.ollama && cap.ollama.model) integrationNotes.push(`Ollama: ${cap.ollama.model}`);
      if (cap.ollama && cap.ollama.embedding_model) integrationNotes.push(`Embed: ${cap.ollama.embedding_model}`);
      const notes = [cap.notes || '', ...integrationNotes].filter(Boolean).join(' • ');
      return toolCard({
        id: `cap-${cap.id}`,
        title: cap.title,
        description: cap.description,
        notes,
        enabled,
        onToggle: `toggleCapability('${cap.id}', ${!enabled})`,
        links,
        ports,
        health,
        actions: actionsHtml,
      });
    }).join('');
  }

  async function runToolAction(action) {
    const payload = {
      name: action.tool || '',
      entrypoint: action.entrypoint || '',
      args: action.args || '',
      allow: true,
    };
    if (!payload.name) {
      setLog('Tool action missing tool name.');
      return;
    }
    const res = await apiPost('/api/tools/run', payload);
    const msg = `${(res.cmd || []).join(' ')}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
    setLog(msg || `Ran ${payload.name}.`);
  }

  async function handleCapabilityAction(capId, idx) {
    const actions = state.capabilityActions[capId] || [];
    const action = actions[idx];
    if (!action) return;
    if (action.type === 'open_url') {
      const target = action.port ? url(state.config, action.port, action.path || '') : action.url || '';
      if (target) window.open(target, '_blank', 'noopener,noreferrer');
      return;
    }
    if (action.type === 'beast_cmd') {
      await runCmd(action.cmd);
      return;
    }
    if (action.type === 'tool_run') {
      await runToolAction(action);
      return;
    }
    if (action.type === 'tool_install') {
      await installTool(action.tool || '');
      return;
    }
    if (action.type === 'extension_install') {
      await installExtension(action.extension || '');
      return;
    }
    if (action.type === 'extension_enable') {
      await toggleExtension(action.extension || '', true);
      return;
    }
    if (action.type === 'pack_enable') {
      await togglePack(action.pack || '', true);
      return;
    }
    if (action.type === 'ollama_pull') {
      const model = action.model || '';
      if (!model) {
        setLog('Missing Ollama model name.');
        return;
      }
      const res = await apiPost('/api/models/pull', { model });
      setLog(res.ok ? `Pulled model ${model}` : (res.error || `Failed to pull model ${model}`));
    }
  }

  async function askCapability(id) {
    const caps = state.capabilities.length ? state.capabilities : CAPABILITIES;
    const cap = caps.find(c => c.id === id);
    if (!cap) return;
    const parts = [
      `Capability: ${cap.title || cap.id}`,
      cap.description || '',
      cap.notes || '',
      `Packs: ${(cap.packs || []).join(', ')}`,
      `Extensions: ${(cap.extensions || []).join(', ')}`,
      `Ports: ${(cap.ports || []).join(', ')}`,
    ].filter(Boolean);
    const prompt = `${parts.join('\n')}\n\nProvide the exact CLI commands or steps to run this capability locally.`;
    try {
      const res = await apiPost('/api/llm/analyze', { prompt });
      setLog(res.ok ? (res.response || 'LLM returned no content.') : (res.error || 'LLM request failed.'));
    } catch (e) {
      setLog(`LLM error: ${e}`);
    }
  }

  function metricRow(label, value) {
    return `<div class="tool"><div class="tool-header"><div class="tool-title">${label}</div><div class="spacer"></div></div><div class="tool-desc">${value}</div></div>`;
  }

  function renderPathsForm() {
    const gutsEl = document.getElementById('gutsDir');
    const heavyEl = document.getElementById('heavyDir');
    if (!gutsEl || !heavyEl) return;
    gutsEl.value = state.config.GUTS_DIR || state.config.BASE_DIR || '';
    heavyEl.value = state.config.HEAVY_DIR || '';
  }

  function setPathsStatus(ok, message) {
    const el = document.getElementById('pathsStatus');
    if (!el) return;
    el.textContent = message;
    if (ok === null) {
      el.className = 'pill';
    } else if (ok) {
      el.className = 'pill ok';
    } else {
      el.className = 'pill bad';
    }
  }

  async function savePaths() {
    const guts = (document.getElementById('gutsDir').value || '').trim();
    const heavy = (document.getElementById('heavyDir').value || '').trim();
    const payload = {};
    if (guts) payload.guts_dir = guts;
    if (heavy) payload.heavy_dir = heavy;
    if (!payload.guts_dir && !payload.heavy_dir) {
      setPathsStatus(false, 'missing');
      return;
    }
    setPathsStatus(null, 'saving...');
    try {
      const res = await apiPost('/api/paths', payload);
      if (res.ok) {
        setPathsStatus(true, 'saved');
        state.config = res.config || state.config;
        renderMetrics();
        renderPathsForm();
      } else {
        setPathsStatus(false, 'error');
        setLog(`${res.error || 'Failed to update paths.'}\n${res.stderr || ''}`.trim());
      }
    } catch (e) {
      setPathsStatus(false, 'error');
    }
  }

  function renderPacks() {
    const el = document.getElementById('packList');
    if (!state.packs.length) {
      el.innerHTML = '<div class="muted">No packs found.</div>';
      return;
    }
    el.innerHTML = state.packs.map(pack => {
      const enabled = !!pack.enabled;
      const extNames = (pack.extensions || []);
      const extPorts = [];
      const links = [];
      extNames.forEach(name => {
        const meta = EXT_INFO[name];
        if (meta && meta.ports) {
          meta.ports.forEach(key => {
            const val = `${key}=${port(state.config, key, '-')}`;
            if (!extPorts.includes(val)) extPorts.push(val);
          });
        }
        if (meta) {
          const portal = typeof meta.portal === 'function' ? meta.portal(state.config) : meta.portal;
          const api = typeof meta.api === 'function' ? meta.api(state.config) : meta.api;
          if (portal) links.push({ label: `${meta.title} Portal`, url: portal });
          if (api) links.push({ label: `${meta.title} API`, url: api });
        }
      });
      if (PACK_LINKS[pack.name]) {
        links.push(...PACK_LINKS[pack.name](state.config));
      }
      const extLabel = extNames.length ? `Extensions: ${extNames.join(', ')}` : '';
      return toolCard({
        id: `pack-${pack.name}`,
        title: pack.name,
        description: pack.desc || 'No description',
        notes: [pack.notes || '', extLabel].filter(Boolean).join(' | '),
        enabled,
        onToggle: `togglePack('${pack.name}', ${!enabled})`,
        links,
        ports: extPorts,
      });
    }).join('');
  }

  function renderExtensions() {
    const el = document.getElementById('extensionList');
    if (!state.extensions.length) {
      el.innerHTML = '<div class="muted">No extensions found.</div>';
      return;
    }
    el.innerHTML = state.extensions.map(ext => {
      const meta = EXT_INFO[ext.name] || { title: ext.name, description: '', ports: [], portal: null, api: null };
      const enabled = ext.enabled === 'true';
      const canInstall = ext.has_installer === 'true';
      const links = [];
      const portal = typeof meta.portal === 'function' ? meta.portal(state.config) : meta.portal;
      const api = typeof meta.api === 'function' ? meta.api(state.config) : meta.api;
      if (portal) links.push({ label: 'Portal', url: portal });
      if (api) links.push({ label: 'API', url: api });
      const ports = (meta.ports || []).map(key => `${key}=${port(state.config, key, '-')}`);
      const actions = canInstall ? `<button class="btn" onclick="installExtension('${ext.name}')">Install</button>` : '';
      return toolCard({
        id: `ext-${ext.name}`,
        title: meta.title || ext.name,
        description: ext.description || meta.description || 'No description',
        notes: '',
        enabled,
        onToggle: `toggleExtension('${ext.name}', ${!enabled})`,
        links,
        ports,
        actions,
      });
    }).join('');
  }

  function renderServices() {
    const el = document.getElementById('serviceList');
    const nativeItems = NATIVE_SERVICES.map(svc => {
      const portal = url(state.config, svc.port, svc.path || '');
      const api = svc.api ? url(state.config, svc.port, svc.api) : '';
      const ports = [ `${svc.port}=${port(state.config, svc.port, '-')}` ];
      const actions = svc.logApp ? `<button class="btn ghost" onclick="fetchAppLogs('${svc.logApp}')">Logs</button>` : '';
      return toolCard({
        id: `svc-native-${svc.name}`,
        title: svc.name,
        description: svc.desc || 'Native service',
        notes: '',
        enabled: true,
        onToggle: '',
        links: [portal ? { label: 'Portal', url: portal } : null, api ? { label: 'API', url: api } : null].filter(Boolean),
        ports,
        readonly: true,
        actions,
      });
    });

    const dockerItems = (state.services || []).map(svc => {
      const ports = (svc.port_keys || []).map(key => `${key}=${port(state.config, key, '-')}`);
      const portal = (svc.port_keys || [])[0] ? url(state.config, svc.port_keys[0], '') : '';
      const notes = [svc.tier ? `tier: ${svc.tier}` : '', (svc.profiles || []).length ? `profiles: ${(svc.profiles || []).join(', ')}` : '']
        .filter(Boolean).join(' • ');
      const actions = `<button class="btn ghost" onclick="fetchServiceLogs('${svc.name}')">Logs</button>`;
      return toolCard({
        id: `svc-${svc.name}`,
        title: svc.name,
        description: svc.image || 'Docker service',
        notes,
        enabled: true,
        onToggle: '',
        links: portal ? [ { label: 'Portal', url: portal } ] : [],
        ports,
        readonly: true,
        actions,
      });
    });

    el.innerHTML = [...nativeItems, ...dockerItems].join('');
  }

  function renderTools() {
    const el = document.getElementById('toolsList');
    if (!el) return;
    const items = (state.tools || []).map(tool => {
      const available = !!tool.available;
      const actions = [];
      if (!available) {
        actions.push(`<button class="btn" onclick="installTool('${tool.name}')">Install</button>`);
      }
      actions.push(`<button class="btn ghost" onclick="openToolConfig('${tool.name}')">Config</button>`);
      actions.push(`<button class="btn ghost" onclick="runTool('${tool.name}')">Run</button>`);
      if (tool.test_command || tool.test_url) {
        actions.push(`<button class="btn ghost" onclick="testTool('${tool.name}')">Test</button>`);
      }
      actions.push(`<button class="btn ghost" onclick="askTool('${tool.name}')">Ask LLM</button>`);
      const notes = tool.runner ? `runner: ${tool.runner}` : '';
      const description = tool.description || tool.entrypoint || tool.name;
      const configHint = tool.config_hint ? `<div class="muted">${tool.config_hint}</div>` : '';
      const argsValue = (tool.args || '');
      const argInput = `<input id="tool-args-${tool.name}" class="token-input" placeholder="args" value="${argsValue}">`;
      return `
        <div id="tool-${tool.name}" class="tool">
          <div class="tool-header">
            <div class="tool-title">${tool.name}</div>
            <div class="spacer"></div>
            <span class="pill ${available ? 'ok' : 'bad'}">${available ? 'available' : 'missing'}</span>
          </div>
          <div class="tool-desc">${description}</div>
          ${notes ? `<div class="muted">${notes}</div>` : ''}
          ${configHint}
          ${argInput}
          <div class="row" style="margin-top: 8px; gap: 8px; flex-wrap: wrap;">
            ${actions.join('')}
          </div>
        </div>
      `;
    });
    el.innerHTML = items.join('') || '<div class="muted">No tools configured.</div>';
  }

  function toolCard({ id, title, description, notes, enabled, onToggle, links, ports, readonly, health, actions }) {
    const toggle = readonly ? '' : `
      <label class="toggle">
        <input type="checkbox" ${enabled ? 'checked' : ''} onchange="${onToggle}">
        <span class="slider"></span>
      </label>`;
    const healthHtml = health ? `<span class="pill" data-health="${health}">checking</span>` : '';
    const linkHtml = (links || []).map(l => `<a class="link" href="${l.url}" target="_blank" rel="noreferrer">${l.label}</a>`).join('');
    const portHtml = (ports || []).length ? `<div class="muted">${ports.join(' | ')}</div>` : '';
    const noteHtml = notes ? `<div class="muted">${notes}</div>` : '';
    const actionsHtml = actions ? `<div class="row" style="margin-top: 8px;">${actions}</div>` : '';
    return `
      <div id="${id}" class="tool">
        <div class="tool-header">
          <div class="tool-title">${title}</div>
          <div class="spacer"></div>
          ${healthHtml}
          ${toggle}
        </div>
        <div class="tool-desc">${description}</div>
        ${noteHtml}
        ${portHtml}
        <div class="tool-links">${linkHtml || '<span class="muted">No links</span>'}</div>
        ${actionsHtml}
      </div>
    `;
  }

  async function fetchServiceLogs(service) {
    setLog(`Fetching logs for ${service}...`, false);
    try {
      const res = await apiPost('/api/services/logs', { service, tail: 200 });
      const out = `${res.cmd ? res.cmd.join(' ') : ''}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
      setLog(out || `No logs for ${service}.`);
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function fetchAppLogs(app) {
    setLog(`Fetching logs for ${app}...`, false);
    try {
      const res = await apiPost('/api/services/logs', { app, tail: 200 });
      const out = `${res.cmd ? res.cmd.join(' ') : ''}\n\n${res.stdout || ''}`.trim();
      setLog(out || `No logs for ${app}.`);
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function installTool(name) {
    setLog(`Fetching tool: ${name}...`, false);
    try {
      const res = await apiPost('/api/tools/install', { name, run_installer: true });
      const out = `${res.cmd ? res.cmd.join(' ') : ''}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
      setLog(out || `Install finished for ${name}.`);
      await loadTools();
      await loadToolCatalog();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function runTool(name) {
    const input = document.getElementById(`tool-args-${name}`);
    const args = input ? input.value : '';
    setLog(`Running ${name}...`, false);
    try {
      const res = await apiPost('/api/tools/run', { name, args });
      const out = `${res.cmd ? res.cmd.join(' ') : ''}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
      setLog(out || `Ran ${name}.`);
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function testTool(name) {
    setLog(`Testing ${name}...`, false);
    try {
      const res = await apiPost('/api/tools/test', { name });
      const out = `${res.cmd ? res.cmd.join(' ') : ''}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim();
      setLog(out || `Tested ${name}.`);
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function setFeature(key, enabled) {
    setLog(`Updating feature ${key}...`, false);
    try {
      const res = await apiPost('/api/features/set', { key, value: enabled ? 'true' : 'false' });
      const out = `${res.merge_stdout || ''}\n${res.sync_stdout || ''}\n${res.merge_stderr || ''}\n${res.sync_stderr || ''}`.trim();
      setLog(out || `Updated ${key}.`);
      await loadFeatures();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function saveFeatureValue(key) {
    const input = document.getElementById(`feature-value-${key}`);
    const value = input ? input.value : '';
    setLog(`Updating feature ${key}...`, false);
    try {
      const res = await apiPost('/api/features/set', { key, value });
      const out = `${res.merge_stdout || ''}\n${res.sync_stdout || ''}\n${res.merge_stderr || ''}\n${res.sync_stderr || ''}`.trim();
      setLog(out || `Updated ${key}.`);
      await loadFeatures();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function setSetting(key, enabled) {
    setLog(`Updating ${key}...`, false);
    try {
      const res = await apiPost('/api/settings/set', { key, value: enabled ? '1' : '0' });
      setLog(res.ok ? `Updated ${key}.` : (res.error || 'Failed to update setting.'));
      await loadSettings();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function saveSetting(key) {
    const input = document.getElementById(`setting-${key}`);
    const value = input ? input.value : '';
    setLog(`Updating ${key}...`, false);
    try {
      const res = await apiPost('/api/settings/set', { key, value });
      setLog(res.ok ? `Updated ${key}.` : (res.error || 'Failed to update setting.'));
      await loadSettings();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function applyFeatureChanges() {
    if (state.applyInFlight) {
      setLog('Apply already running...', false);
      return;
    }
    state.applyInFlight = true;
    setLog('Applying feature changes...', false);
    try {
      await runCmd('compose_gen');
      await runCmd('up');
      await loadServices();
    } catch (e) {
      setLog(`Error: ${e}`);
    } finally {
      state.applyInFlight = false;
    }
  }

  async function applyAfterToggle() {
    await applyFeatureChanges();
  }

  function selectedCatalogTools() {
    const select = document.getElementById('toolCatalogSelect');
    if (!select) return [];
    return Array.from(select.selectedOptions || []).map(opt => opt.value).filter(Boolean);
  }

  async function addSelectedTools() {
    const names = selectedCatalogTools();
    if (!names.length) {
      setLog('Select one or more tools to add.');
      return;
    }
    setLog(`Adding tools: ${names.join(', ')}...`, false);
    try {
      const results = [];
      for (const name of names) {
        const res = await apiPost('/api/tools/register', { name, source: 'catalog' });
        results.push(`${name}: ${res.ok ? 'added' : (res.error || 'error')}`);
      }
      setLog(results.join('\n'));
      await loadTools();
      await loadToolCatalog();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function installSelectedTools() {
    const names = selectedCatalogTools();
    if (!names.length) {
      setLog('Select one or more tools to install.');
      return;
    }
    setLog(`Installing tools: ${names.join(', ')}...`, false);
    try {
      const res = await apiPost('/api/tools/install_bulk', { names, run_installer: true });
      const lines = (res.items || []).map(item => {
        const ok = item.ok ? 'ok' : (item.error || 'error');
        return `${item.name}: ${ok}`;
      });
      setLog(lines.join('\n') || 'Install finished.');
      await loadTools();
      await loadToolCatalog();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function registerCustomTool() {
    const name = (document.getElementById('customToolName')?.value || '').trim();
    const url = (document.getElementById('customToolUrl')?.value || '').trim();
    const entrypoint = (document.getElementById('customToolEntrypoint')?.value || '').trim();
    const test_command = (document.getElementById('customToolTest')?.value || '').trim();
    if (!name || !url) {
      setLog('Provide both tool name and download URL.');
      return;
    }
    setLog(`Registering ${name}...`, false);
    try {
      const res = await apiPost('/api/tools/register', {
        name,
        source: 'custom',
        download_url: url,
        entrypoint,
        test_command,
      });
      setLog(res.ok ? `Added ${name}.` : (res.error || 'Failed to add tool.'));
      await loadTools();
      await loadToolCatalog();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function registerAndInstallCustomTool() {
    await registerCustomTool();
    const name = (document.getElementById('customToolName')?.value || '').trim();
    if (!name) return;
    await installTool(name);
  }

  function openToolConfig(name) {
    const tool = toolConfig(name);
    if (!tool) return;
    state.currentToolName = name;
    document.getElementById('toolModalTitle').textContent = tool.description || name;
    document.getElementById('toolEntry').value = tool.entrypoint || '';
    document.getElementById('toolArgs').value = tool.args || '';
    document.getElementById('toolTestCmd').value = tool.test_command || '';
    document.getElementById('toolTestUrl').value = tool.test_url || '';
    document.getElementById('toolDownloadUrl').value = tool.download_url || '';
    document.getElementById('toolInstallCmd').value = tool.install_command || '';
    document.getElementById('toolEnv').value = JSON.stringify(tool.env || {}, null, 2);
    document.getElementById('toolConfigHint').value = tool.config_hint || '';
    document.getElementById('toolWorkflow').value = tool.workflow || '';
    const modal = document.getElementById('toolModal');
    if (modal) modal.style.display = 'flex';
  }

  function closeToolModal() {
    const modal = document.getElementById('toolModal');
    if (modal) modal.style.display = 'none';
  }

  async function saveToolConfig() {
    const name = state.currentToolName;
    if (!name) {
      setLog('Missing tool name.');
      return;
    }
    let env = {};
    try {
      env = JSON.parse(document.getElementById('toolEnv').value || '{}');
    } catch (e) {
      setLog(`Invalid env JSON: ${e}`);
      return;
    }
    const updates = {
      entrypoint: document.getElementById('toolEntry').value || '',
      args: document.getElementById('toolArgs').value || '',
      test_command: document.getElementById('toolTestCmd').value || '',
      test_url: document.getElementById('toolTestUrl').value || '',
      download_url: document.getElementById('toolDownloadUrl').value || '',
      install_command: document.getElementById('toolInstallCmd').value || '',
      env,
      config_hint: document.getElementById('toolConfigHint').value || '',
      workflow: document.getElementById('toolWorkflow').value || '',
    };
    try {
      const res = await apiPost('/api/tools/update', { name, updates });
      if (res.ok) {
        setLog(`Saved tool ${name}.`);
        closeToolModal();
        await loadTools();
        await loadToolCatalog();
      } else {
        setLog(res.error || 'Failed to save tool.');
      }
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function askTool(name) {
    const tool = toolConfig(name);
    const prompt = `How do I use ${name}?\nEntry: ${tool?.entrypoint || name}\nArgs: ${tool?.args || ''}\nTest: ${tool?.test_command || tool?.test_url || ''}`.trim();
    try {
      const res = await apiPost('/api/llm/analyze', { prompt });
      setLog(res.ok ? (res.response || 'LLM returned no content.') : (res.error || 'LLM request failed.'));
    } catch (e) {
      setLog(`LLM error: ${e}`);
    }
  }

  async function installExtension(name) {
    setLog(`Installing extension: ${name}...`, false);
    try {
      const res = await apiPost('/api/extensions/install', { name });
      setLog(`${res.cmd ? res.cmd.join(' ') : 'install'}\n\n${res.stdout || ''}\n${res.stderr || ''}`.trim());
      await loadExtensions();
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  async function toggleExtension(name, enable, skipApply = false) {
    await apiPost('/api/toggle', { kind: 'extension', name, enable });
    await loadExtensions();
    renderCapabilities();
    if (!skipApply) {
    }
  }

  async function togglePack(name, enable, skipApply = false) {
    await apiPost('/api/toggle', { kind: 'pack', name, enable });
    await loadPacks();
    renderCapabilities();
    if (!skipApply) {
    }
  }

  async function toggleCapability(id, enable) {
    const cap = CAPABILITIES.find(c => c.id === id);
    if (!cap) return;
    if (enable) {
      for (const pack of (cap.packs || [])) {
        if (!packEnabled(pack)) {
          await togglePack(pack, true, true);
        }
      }
      for (const ext of (cap.extensions || [])) {
        if (!extensionEnabled(ext)) {
          await toggleExtension(ext, true, true);
        }
      }
      if ((cap.packs || []).includes('speech_stack')) {
        await runCmd('speech_up');
      }
    } else {
      for (const ext of (cap.extensions || [])) {
        if (extensionEnabled(ext)) {
          await toggleExtension(ext, false, true);
        }
      }
      for (const pack of (cap.packs || [])) {
        const stillNeeded = CAPABILITIES.some(other => {
          if (other.id === cap.id) return false;
          if (!capabilityEnabled(other)) return false;
          return (other.packs || []).includes(pack);
        });
        if (!stillNeeded && packEnabled(pack)) {
          await togglePack(pack, false, true);
        }
      }
      if ((cap.packs || []).includes('speech_stack')) {
        await runCmd('speech_down');
      }
    }
    renderCapabilities();
  }

  async function checkHealth() {
    const nodes = document.querySelectorAll('[data-health]');
    await Promise.all(Array.from(nodes).map(async node => {
      const url = node.getAttribute('data-health');
      if (!url) return;
      try {
        const res = await fetch(url, { method: 'GET' });
        node.textContent = res.ok ? 'ok' : 'down';
        node.className = res.ok ? 'pill ok' : 'pill bad';
      } catch (e) {
        node.textContent = 'down';
        node.className = 'pill bad';
      }
    }));
  }

  async function runCmd(cmd) {
    setLog(`Running: ${cmd}...`, false);
    try {
      const res = await fetch(`/api/run?cmd=${encodeURIComponent(cmd)}`, {
        headers: { 'X-Beast-Token': state.token }
      });
      const data = await res.json();
      setLog(`${data.cmd ? data.cmd.join(' ') : cmd}\n\n${data.stdout || ''}\n${data.stderr || ''}`.trim());
    } catch (e) {
      setLog(`Error: ${e}`);
    }
  }

  refreshAll();
</script>
</body>
</html>
